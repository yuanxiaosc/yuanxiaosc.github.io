<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-32x32.ico?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico?v=7.4.1">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="baidu-site-verification" content="eYmWT0dEmt">

<link rel="stylesheet" href="/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":true,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="数据结构与算法题解：旨在使用Python语言解决面试中常见的算法编程题（持续更新）。更多用Python实现的算法参见 TheAlgorithms/Python编者：袁宵1人生苦短，我用 Python算法题">
<meta name="keywords" content="自然语言处理,深度学习,机器学习,人工智能,论文">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法题解">
<meta property="og:url" content="https://yuanxiaosc.github.io/2019/08/29/数据结构算法题解/index.html">
<meta property="og:site_name" content="望江人工智库">
<meta property="og:description" content="数据结构与算法题解：旨在使用Python语言解决面试中常见的算法编程题（持续更新）。更多用Python实现的算法参见 TheAlgorithms/Python编者：袁宵1人生苦短，我用 Python算法题">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190124112735774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzU5MDUx,size_16,color_FFFFFF,t_70">
<meta property="og:updated_time" content="2019-10-28T06:33:26.432Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据结构与算法题解">
<meta name="twitter:description" content="数据结构与算法题解：旨在使用Python语言解决面试中常见的算法编程题（持续更新）。更多用Python实现的算法参见 TheAlgorithms/Python编者：袁宵1人生苦短，我用 Python算法题">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190124112735774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzU5MDUx,size_16,color_FFFFFF,t_70">
  <link rel="canonical" href="https://yuanxiaosc.github.io/2019/08/29/数据结构算法题解/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>数据结构与算法题解 | 望江人工智库</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?359fbde2215e8ede98cdd58478ab2c53";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">望江人工智库</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">TF-KMP</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="fa fa-search fa-fw"></i>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/yuanxiaosc" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuanxiaosc.github.io/2019/08/29/数据结构算法题解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="袁宵">
      <meta itemprop="description" content="专注于人工智能领域研究，特别是自然语言处理。">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="望江人工智库">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">数据结构与算法题解

          
        </h2>

        <div class="post-meta">
		  	  
			  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
			   

              
                
              

              <time title="创建时间：2019-08-29 08:30:15" itemprop="dateCreated datePublished" datetime="2019-08-29T08:30:15+08:00">2019-08-29</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-28 14:33:26" itemprop="dateModified" datetime="2019-10-28T14:33:26+08:00">2019-10-28</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数学/" itemprop="url" rel="index"><span itemprop="name">数学</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>数据结构与算法题解：旨在使用Python语言解决面试中常见的算法编程题（持续更新）。<br>更多用Python实现的算法参见 <a href="https://github.com/TheAlgorithms/Python" target="_blank" rel="noopener">TheAlgorithms/Python</a></p><p>编者：袁宵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">人生苦短，我用 Python</span><br></pre></td></tr></table></figure><h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><a id="more"></a>


<h3 id="在-m-n-的乘法表中找到第k小的数的值"><a href="#在-m-n-的乘法表中找到第k小的数的值" class="headerlink" title="在 m*n 的乘法表中找到第k小的数的值"></a>在 m*n 的乘法表中找到第k小的数的值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_Kth_Number</span><span class="params">(m, n, k)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    在 m*n 的乘法表中找到第k小的数的值</span></span><br><span class="line"><span class="string">    :param m: 乘法表行数</span></span><br><span class="line"><span class="string">    :param n: 乘法表列数</span></span><br><span class="line"><span class="string">    :param k: 第k小的数</span></span><br><span class="line"><span class="string">    :return: 第k小的数的值</span></span><br><span class="line"><span class="string">    输入: m = 3, n = 3, k = 5</span></span><br><span class="line"><span class="string">    输出: 3</span></span><br><span class="line"><span class="string">    解释:</span></span><br><span class="line"><span class="string">    乘法表:</span></span><br><span class="line"><span class="string">    1	2	3</span></span><br><span class="line"><span class="string">    2	4	6</span></span><br><span class="line"><span class="string">    3	6	9</span></span><br><span class="line"><span class="string">    第5小的数字是 3 (1, 2, 2, 3, 3).</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    left = <span class="number">1</span></span><br><span class="line">    right = m * n</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> mid &gt; n * i: <span class="comment"># mid大于n*i，那么这一行的数都算进去</span></span><br><span class="line">                count += n</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count += mid // i <span class="comment"># mid在第i行排的次序</span></span><br><span class="line">        <span class="keyword">if</span> count &lt; k:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    m, n, k = list(map(int, input().split(<span class="string">" "</span>)))</span><br><span class="line">    print(find_Kth_Number(m, n, k))</span><br></pre></td></tr></table></figure>
<h3 id="查找数组中元素的最大值与最小值"><a href="#查找数组中元素的最大值与最小值" class="headerlink" title="查找数组中元素的最大值与最小值"></a>查找数组中元素的最大值与最小值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetMaxAndMin</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    查找数组中元素的最大值与最小值</span></span><br><span class="line"><span class="string">    :param array: 数组</span></span><br><span class="line"><span class="string">    :return: 数组中的最大值和最小值</span></span><br><span class="line"><span class="string">    使用二分查找思想</span></span><br><span class="line"><span class="string">    时间复杂度 3n/2 - 2，空间复杂度 1</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    array_len = len(array)</span><br><span class="line">    <span class="keyword">if</span> array <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> array_len == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    array_max = array[<span class="number">0</span>]</span><br><span class="line">    array_min = array[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 两两分组，把较小的数放在左半部分，较大的数放在右半部分</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, array_len - <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> array[i] &gt; array[i+<span class="number">1</span>]:</span><br><span class="line">            array[i], array[i+<span class="number">1</span>] = array[i+<span class="number">1</span>], array[i]</span><br><span class="line">    <span class="comment"># 在各个分组中的左半部分找最小值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, array_len, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> array_min &gt; array[i]:</span><br><span class="line">            array_min = array[i]</span><br><span class="line">    <span class="comment"># 在各个分组中的右半部分找最大值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, array_len, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> array_max &lt; array[i]:</span><br><span class="line">            array_max = array[i]</span><br><span class="line">    <span class="comment"># 如果数组元素个数是奇数个，最后一个元素被分为一组，需要特殊处理</span></span><br><span class="line">    <span class="keyword">if</span> array_len % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> array_min &gt; array[<span class="number">-1</span>]:</span><br><span class="line">            array_min = array[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">elif</span> array_max &lt; array[<span class="number">-1</span>]:</span><br><span class="line">            array_max = array[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> (array_min, array_max)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    array = list(map(int, input().strip().split()))</span><br><span class="line">    print(GetMaxAndMin(array))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetMaxAndMin</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    查找数组中元素的最大值与最小值</span></span><br><span class="line"><span class="string">    :param array: 数组</span></span><br><span class="line"><span class="string">    :return: (最小值,最大值) 元组</span></span><br><span class="line"><span class="string">    使用二分查找思想</span></span><br><span class="line"><span class="string">    时间复杂度 3n/2 - 2</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    array_len = len(array)</span><br><span class="line">    <span class="keyword">if</span> array <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> array_len == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_recursive_operation</span><span class="params">(array, left, right)</span>:</span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span> <span class="comment"># 求中点</span></span><br><span class="line">        <span class="keyword">if</span> left == right: <span class="comment"># left 和 right 间只有一个元素</span></span><br><span class="line">            <span class="keyword">return</span> (array[mid], array[mid])</span><br><span class="line">        <span class="keyword">if</span> left + <span class="number">1</span> == right: <span class="comment"># left 和 right 间只有两个个元素</span></span><br><span class="line">            <span class="keyword">if</span> array[left] &gt; array[right]:</span><br><span class="line">                <span class="keyword">return</span> (array[right], array[left])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> (array[left], array[right])</span><br><span class="line">        <span class="comment"># 递归计算左半部分</span></span><br><span class="line">        left_array = _recursive_operation(array, left, mid)</span><br><span class="line">        <span class="comment"># 递归计算右半部分</span></span><br><span class="line">        right_array = _recursive_operation(array, mid+<span class="number">1</span>, right)</span><br><span class="line">        <span class="comment"># 总的最小值</span></span><br><span class="line">        array_min = left_array[<span class="number">0</span>] <span class="keyword">if</span> left_array[<span class="number">0</span>] &lt; right_array[<span class="number">0</span>] <span class="keyword">else</span> right_array[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 总的最大值</span></span><br><span class="line">        array_max = left_array[<span class="number">1</span>] <span class="keyword">if</span> left_array[<span class="number">1</span>] &gt; right_array[<span class="number">1</span>] <span class="keyword">else</span> right_array[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> (array_min, array_max)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _recursive_operation(array, <span class="number">0</span>, array_len<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    array = list(map(int, input().strip().split()))</span><br><span class="line">    print(GetMaxAndMin(array))</span><br></pre></td></tr></table></figure>
<h3 id="查找旋转数组中的最小元素"><a href="#查找旋转数组中的最小元素" class="headerlink" title="查找旋转数组中的最小元素"></a>查找旋转数组中的最小元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">有一个数组X[0...n-1]，现在把它分为两个子数组：X1[0...m] 和 X2[m+1...n-1]，</span></span><br><span class="line"><span class="string">交换者两个子数组，使数组X由X1X2变成X2X1，求变换后数组X的最小值。</span></span><br><span class="line"><span class="string">例如 X=[1,2,3,4,5,6,7,8,9]，X1=[1,2,3,4,5]，X2=[6,7,8,9]，</span></span><br><span class="line"><span class="string">交换后，X=[6,7,8,9,1,2,3,4,5]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetMin</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    查找旋转数组中的最小元素</span></span><br><span class="line"><span class="string">    :param array: 旋转数组</span></span><br><span class="line"><span class="string">    :return: 最小值</span></span><br><span class="line"><span class="string">    时间复杂度 :大部分情况 log2N，极端情况 N</span></span><br><span class="line"><span class="string">    最容易想到的是直接遍历法，但是没有用到旋转数组的特性，时间复杂度为N。</span></span><br><span class="line"><span class="string">    可以用二分法解决。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    array_len = len(array)</span><br><span class="line">    <span class="keyword">if</span> array <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> array_len == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = array_len - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_recursive_operation</span><span class="params">(array, left, right)</span>:</span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span> <span class="comment"># 求中点</span></span><br><span class="line">        <span class="comment"># 判断 array[mid] 是否为最小值</span></span><br><span class="line">        <span class="keyword">if</span> (mid - <span class="number">1</span>) &gt;= left <span class="keyword">and</span> array[mid] &lt; array[mid - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> array[mid]</span><br><span class="line">        <span class="comment"># 判断 array[mid + 1] 是否为最小值</span></span><br><span class="line">        <span class="keyword">elif</span> (mid + <span class="number">1</span>) &lt;= right <span class="keyword">and</span> array[mid + <span class="number">1</span>] &lt; array[mid]:</span><br><span class="line">            <span class="keyword">return</span> array[mid + <span class="number">1</span>]</span><br><span class="line">        <span class="comment"># left 和 right 间只有一个元素</span></span><br><span class="line">        <span class="keyword">elif</span> left == right:</span><br><span class="line">            <span class="keyword">return</span> array[mid]</span><br><span class="line">        <span class="comment"># left 和 right 间只有两个个元素</span></span><br><span class="line">        <span class="keyword">elif</span> left + <span class="number">1</span> == right:</span><br><span class="line">            <span class="keyword">return</span> array[left] <span class="keyword">if</span> array[right] &gt; array[left] <span class="keyword">else</span> array[right]</span><br><span class="line">        <span class="comment"># 如果 array[right] &gt; array[mid]，则最小值一定在数组左半部分</span></span><br><span class="line">        <span class="keyword">elif</span> array[right] &gt; array[mid]:</span><br><span class="line">            <span class="keyword">return</span> _recursive_operation(array, left, mid)</span><br><span class="line">        <span class="comment"># 如果 array[mid] &gt; array[left]，则最小值一定在数组右半部分</span></span><br><span class="line">        <span class="keyword">elif</span> array[mid] &gt; array[left]:</span><br><span class="line">            <span class="keyword">return</span> _recursive_operation(array, mid, right)</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># array[right] == array[mid] 且 array[mid] == array[left]，</span></span><br><span class="line">            <span class="comment"># 无法确定最小值所在位置，只能对左右两部分分别查找</span></span><br><span class="line">            <span class="comment"># 递归计算左半部分</span></span><br><span class="line">            left_min = _recursive_operation(array, left, mid)</span><br><span class="line">            <span class="comment"># 递归计算右半部分</span></span><br><span class="line">            right_min = _recursive_operation(array, mid+<span class="number">1</span>, right)</span><br><span class="line">            <span class="comment"># 总的最小值</span></span><br><span class="line">            array_min = left_min <span class="keyword">if</span> left_min &lt; right_min <span class="keyword">else</span> right_min</span><br><span class="line">        <span class="keyword">return</span> array_min</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _recursive_operation(array, left, right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    array = list(map(int, input().strip().split()))</span><br><span class="line">    print(GetMaxAndMin(array))</span><br></pre></td></tr></table></figure>
<p>生成旋转数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(array, left, right)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        array[right], array[left] = array[left], array[right]</span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">        right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotateArray</span><span class="params">(array, division_location)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    生成旋转数组</span></span><br><span class="line"><span class="string">    :param array: 顺序数组</span></span><br><span class="line"><span class="string">    :param division_location: 旋转的位置</span></span><br><span class="line"><span class="string">    :return: 旋转数组</span></span><br><span class="line"><span class="string">    先分别把两个子数组内容交换，然后再把整个数组内容交换。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    swap(array, <span class="number">0</span>, division_location)</span><br><span class="line">    swap(array, division_location+<span class="number">1</span>, len(array) - <span class="number">1</span>)</span><br><span class="line">    swap(array, <span class="number">0</span>, len(array) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    division_location = int(input())</span><br><span class="line">    array = list(map(int, input().strip().split()))</span><br><span class="line">    rotateArray(array, division_location)</span><br><span class="line">    print(array)</span><br></pre></td></tr></table></figure>
<h3 id="找出数组中第k小的数"><a href="#找出数组中第k小的数" class="headerlink" title="找出数组中第k小的数"></a>找出数组中第k小的数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_small_k_number</span><span class="params">(array, k)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    找出数组中第k小的数</span></span><br><span class="line"><span class="string">    :param array: 整数数组</span></span><br><span class="line"><span class="string">    :return: 第k小的数</span></span><br><span class="line"><span class="string">    部分快速排序方法</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick_sort_operation</span><span class="params">(array, left, right, k)</span>:</span></span><br><span class="line">        i = left</span><br><span class="line">        j = right</span><br><span class="line">        split_elem = array[i]</span><br><span class="line">        <span class="comment"># 把大于等于split_elem的数放在数组右边，把小于split_elem的数放在数组左边</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> array[j] &gt;= split_elem:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            array[i] = array[j]</span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> array[i] &lt; split_elem:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            array[j] = array[i]</span><br><span class="line">        <span class="comment"># 当i=j时，i就是split_elem插入数组的位置，且表示该split_elem就是数组中排行第i的数</span></span><br><span class="line">        array[i] = split_elem</span><br><span class="line">        <span class="comment"># 小于split_elem的数字个数</span></span><br><span class="line">        left_sub_array_item_number = i - left</span><br><span class="line">        <span class="comment"># 如果小于split_elem的数字个数恰好为 k-1，那么 i 对应的位置就是第k小数字的位置</span></span><br><span class="line">        <span class="keyword">if</span> left_sub_array_item_number == k - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> array[i]</span><br><span class="line">        <span class="comment"># 如果小于split_elem的数字个数大于 k-1，那么只需在array[low, i-1] 中继续寻找</span></span><br><span class="line">        <span class="keyword">elif</span> left_sub_array_item_number &gt; k - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> quick_sort_operation(array, left, i - <span class="number">1</span>, k)</span><br><span class="line">        <span class="comment"># 在array[i+1, high]中寻找第 k - left_sub_array_item_number - 1 的数字</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> quick_sort_operation(array, i + <span class="number">1</span>, right, k - left_sub_array_item_number - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> quick_sort_operation(array, <span class="number">0</span>, len(array) - <span class="number">1</span>, k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    k = int(input())</span><br><span class="line">    array = list(map(int, input().strip().split()))</span><br><span class="line">    print(find_small_k_number(array, k))</span><br></pre></td></tr></table></figure>
<h3 id="找出数组前3大的数"><a href="#找出数组前3大的数" class="headerlink" title="找出数组前3大的数"></a>找出数组前3大的数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findTop3</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    查找数组中前三大的数</span></span><br><span class="line"><span class="string">    :param array: 长度不小于3的数组</span></span><br><span class="line"><span class="string">    :return: (num1, num2, num3) 数组中值最大的3个数组成的元组</span></span><br><span class="line"><span class="string">    时间复杂度: O(N)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    r1 = r2 = r3 = - <span class="number">2</span>**<span class="number">31</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> array:</span><br><span class="line">        <span class="keyword">if</span> item &gt; r1:</span><br><span class="line">            r3 = r2</span><br><span class="line">            r2 = r1</span><br><span class="line">            r1 = item</span><br><span class="line">        <span class="keyword">elif</span> item &gt; r2:</span><br><span class="line">            r3 = r2</span><br><span class="line">            r2 = item</span><br><span class="line">        <span class="keyword">elif</span> item &gt; r1:</span><br><span class="line">            r3 = item</span><br><span class="line">    <span class="keyword">return</span> (r1, r2, r3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    array = list(map(int, input().strip().split(<span class="string">" "</span>)))</span><br><span class="line">    print(findTop3(array))</span><br></pre></td></tr></table></figure>
<h3 id="找出数组前K大的数"><a href="#找出数组前K大的数" class="headerlink" title="找出数组前K大的数"></a>找出数组前K大的数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_adjust</span><span class="params">(array, start, end)</span>:</span></span><br><span class="line">    <span class="string">"""调整堆为小顶堆"""</span></span><br><span class="line">    temp = array[start]</span><br><span class="line">    child = <span class="number">2</span> * start</span><br><span class="line">    <span class="keyword">while</span> child &lt;= end:</span><br><span class="line">        <span class="keyword">if</span> child &lt; end <span class="keyword">and</span> array[child] &gt; array[child + <span class="number">1</span>]:</span><br><span class="line">            child += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> temp &lt;= array[child]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        array[start] = array[child]</span><br><span class="line">        start = child</span><br><span class="line">        child = start * <span class="number">2</span></span><br><span class="line">    array[start] = temp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findTopK</span><span class="params">(array, K)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    找出数组中前K大的数</span></span><br><span class="line"><span class="string">    :param array: 数组</span></span><br><span class="line"><span class="string">    :param K: 前K大的数</span></span><br><span class="line"><span class="string">    :return: (num1,..,numK) 前K大的数组成的元组</span></span><br><span class="line"><span class="string">    当K和数组长度比较大的时候，适合用“堆”方法找出数组中前K大的数</span></span><br><span class="line"><span class="string">    时间复杂度 O(N*log_2 K)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt; K:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    top_k_heap = [<span class="number">0</span>] + array[<span class="number">0</span>:K]  <span class="comment"># 添加辅助位置0</span></span><br><span class="line">    top_k_heap_len = K</span><br><span class="line">    <span class="comment"># 现在的待排序序列构建成一个小顶堆</span></span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> range(top_k_heap_len // <span class="number">2</span>, <span class="number">0</span>, <span class="number">-1</span>):  <span class="comment"># 对 input_list_len // 2 个父亲节点处理</span></span><br><span class="line">        heap_adjust(top_k_heap, start, top_k_heap_len)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> array[K:]:</span><br><span class="line">        <span class="keyword">if</span> item &gt; top_k_heap[<span class="number">1</span>]:</span><br><span class="line">            top_k_heap[<span class="number">1</span>] = item</span><br><span class="line">            heap_adjust(top_k_heap, <span class="number">1</span>, top_k_heap_len)</span><br><span class="line">    <span class="comment"># 逐步将堆结构转换为排序好的数列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 逐步将每个最小值的根结点与末尾元素交换，并且再调整其成为小顶堆</span></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> range(top_k_heap_len, <span class="number">1</span>, <span class="number">-1</span>):  <span class="comment"># 遍历次数，需要找到 input_list_len - 1 次最值来交换</span></span><br><span class="line">        top_k_heap[<span class="number">1</span>], top_k_heap[end] = top_k_heap[end], top_k_heap[<span class="number">1</span>]  <span class="comment"># 交换最值</span></span><br><span class="line">        heap_adjust(top_k_heap, <span class="number">1</span>, end - <span class="number">1</span>)  <span class="comment"># 重新调整堆</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">del</span> top_k_heap[<span class="number">0</span>] <span class="comment"># 删除辅助位置0</span></span><br><span class="line">    <span class="keyword">return</span> tuple(top_k_heap)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    K = int(input())</span><br><span class="line">    array = list(map(int, input().strip().split(<span class="string">" "</span>)))</span><br><span class="line">    print(findTopK(array, K))</span><br></pre></td></tr></table></figure>
<h3 id="找三个有序数组的公共元素"><a href="#找三个有序数组的公共元素" class="headerlink" title="找三个有序数组的公共元素"></a>找三个有序数组的公共元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_common</span><span class="params">(ar1, ar2, ar3)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    找三个有序数组的公共元素</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    i, j, k = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    n1, n2, n3 = len(ar1), len(ar2), len(ar3)</span><br><span class="line">    <span class="keyword">while</span> i &lt; n1 <span class="keyword">and</span> j &lt; n2 <span class="keyword">and</span> k &lt; n3:</span><br><span class="line">        <span class="keyword">if</span> ar1[i] == ar2[j] <span class="keyword">and</span> ar2[j] == ar3[k]:</span><br><span class="line">            print(ar1[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> ar1[i] &lt; ar2[j]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> ar2[j] &lt; ar3[k]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ar1 = list(map(int, input().split()))  <span class="comment"># 2 5 12 20 45 85</span></span><br><span class="line">    ar2 = list(map(int, input().split()))  <span class="comment"># 16 19 20 85 200</span></span><br><span class="line">    ar3 = list(map(int, input().split()))  <span class="comment"># 3 4 15 20 39 72 85 190</span></span><br><span class="line">    find_common(ar1, ar2, ar3)  <span class="comment"># 20 85</span></span><br></pre></td></tr></table></figure>
<h3 id="求数组中两个元素的最小距离"><a href="#求数组中两个元素的最小距离" class="headerlink" title="求数组中两个元素的最小距离"></a>求数组中两个元素的最小距离</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_distance</span><span class="params">(array, num1, num2)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    求数组中两个元素的最小距离</span></span><br><span class="line"><span class="string">    :param array: 数组</span></span><br><span class="line"><span class="string">    :param num1: 元素1</span></span><br><span class="line"><span class="string">    :param num2: 元素2</span></span><br><span class="line"><span class="string">    :return: 最小距离</span></span><br><span class="line"><span class="string">    时间复杂度 O(N)</span></span><br><span class="line"><span class="string">    动态规划方法，把每次遍历的结果都记录下来。</span></span><br><span class="line"><span class="string">    这里利用了最小距离一定是依次遍历数组时最近访问的两个位置（局部性）。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt; <span class="number">2</span> <span class="keyword">or</span> num1 <span class="keyword">not</span> <span class="keyword">in</span> array <span class="keyword">or</span> num2 <span class="keyword">not</span> <span class="keyword">in</span> array:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    min_d = <span class="number">2</span> ** <span class="number">31</span></span><br><span class="line">    last_position_1 = <span class="number">-1</span></span><br><span class="line">    last_position_2 = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, item <span class="keyword">in</span> enumerate(array):</span><br><span class="line">        <span class="keyword">if</span> num1 == item:</span><br><span class="line">            last_position_1 = idx</span><br><span class="line">            <span class="keyword">if</span> last_position_2 &gt;= <span class="number">0</span>:</span><br><span class="line">                min_d = min(min_d, last_position_1 - last_position_2)</span><br><span class="line">        <span class="keyword">if</span> num2 == item:</span><br><span class="line">            last_position_2 = idx</span><br><span class="line">            <span class="keyword">if</span> last_position_1 &gt;= <span class="number">0</span>:</span><br><span class="line">                min_d = min(min_d, last_position_2 - last_position_1)</span><br><span class="line">    <span class="keyword">return</span> min_d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    num1, num2 = list(map(int, input().strip().split(<span class="string">" "</span>)))</span><br><span class="line">    array = list(map(int, input().strip().split(<span class="string">" "</span>)))</span><br><span class="line">    print(min_distance(array, num1, num2))</span><br></pre></td></tr></table></figure>
<h3 id="异或法"><a href="#异或法" class="headerlink" title="异或法"></a>异或法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swapTwoInteger</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    使用异或操作交换整数值</span></span><br><span class="line"><span class="string">    :param a: int</span></span><br><span class="line"><span class="string">    :param b: int</span></span><br><span class="line"><span class="string">    :return: (b, a)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    a = a ^ b</span><br><span class="line">    b = a ^ b</span><br><span class="line">    a = a ^ b</span><br><span class="line">    <span class="keyword">return</span> a, b</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a, b = list(map(int, input().strip().split(<span class="string">" "</span>)))</span><br><span class="line">    print(swapTwoInteger(a, b))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDuplicateNumber</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    查找数组中重复的整数</span></span><br><span class="line"><span class="string">    :param array: n-1 个整数组成的未排序的数组序列，其元素是1到n中不同的整数。</span></span><br><span class="line"><span class="string">    :return: 数组序列中重复的整数</span></span><br><span class="line"><span class="string">    时间复杂度：n，空间复杂度 1</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    array_len = len(array)</span><br><span class="line">    <span class="comment"># a = 1^2^3..(m)^(m)..^n</span></span><br><span class="line">    a = array[<span class="number">0</span>]</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; array_len:</span><br><span class="line">        a = a ^ array[i]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="comment"># b = 1^2^3..^n</span></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line">    i = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; array_len:</span><br><span class="line">        b = b ^ i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="comment"># a ^ b = (1^1)^(2^2)...(m^m^m)...^(n^n) = m</span></span><br><span class="line">    <span class="keyword">return</span> a ^ b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    array = list(map(int, input().strip().split()))</span><br><span class="line">    print(findDuplicateNumber(array))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMissedNumber</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    查找数组中丢失的整数</span></span><br><span class="line"><span class="string">    :param array: n-1 个整数组成的未排序的数组序列，其元素是1到n中不同的整数。</span></span><br><span class="line"><span class="string">    :return: 数组序列中缺失的整数</span></span><br><span class="line"><span class="string">    时间复杂度：n，空间复杂度 1</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    array_len = len(array)</span><br><span class="line">    <span class="comment"># a = 1^2^3..(m-1)^(m+1)..^n</span></span><br><span class="line">    a = array[<span class="number">0</span>]</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; array_len:</span><br><span class="line">        a = a ^ array[i]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="comment"># b = 1^2^3..^n</span></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line">    i = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; array_len + <span class="number">2</span>:</span><br><span class="line">        b = b ^ i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="comment"># a ^ b = (1^1)^(2^2)...(m-1)^(m-1)^m^(m+1)^(m+1)^...^(n^n) = m</span></span><br><span class="line">    <span class="keyword">return</span> a ^ b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    array = list(map(int, input().strip().split()))</span><br><span class="line">    print(findMissedNumber(array))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_single</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    找出特殊数组中的任意一个特殊的数</span></span><br><span class="line"><span class="string">    :param array: 一个数组，除了三个数是唯一的，其余的数出现偶数次</span></span><br><span class="line"><span class="string">    :return: 任意一个特殊的数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 遍历数字二进制位的每一位</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="number">32</span>:</span><br><span class="line">        result1 = result2 = count1 = count2 = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历数组的每个数字，并根据数字的第i为是否为1进行分类</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> (item &gt;&gt; i) &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">                result1 ^= item</span><br><span class="line">                count1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result2 ^= item</span><br><span class="line">                count2 += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果result1某次计数count1为奇数且result2的结果不为零</span></span><br><span class="line">        <span class="comment"># 说明result1结果里面只包含了一个出现次数为1的数</span></span><br><span class="line">        <span class="keyword">if</span> count1 % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">and</span> result2 != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> result1</span><br><span class="line">        <span class="keyword">if</span> count2 % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">and</span> result1 != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> result2</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    array = list(map(int, input().strip().split(<span class="string">" "</span>)))</span><br><span class="line">    print(find_single(array))</span><br></pre></td></tr></table></figure>
<h3 id="求数组连续最大和"><a href="#求数组连续最大和" class="headerlink" title="求数组连续最大和"></a>求数组连续最大和</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_sub_array</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    求数组连续最大和</span></span><br><span class="line"><span class="string">    :param array: 数组</span></span><br><span class="line"><span class="string">    :return: 数组连续最大和</span></span><br><span class="line"><span class="string">    时间复杂度 O(N) 空间复杂度 O(1)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    n = len(array)</span><br><span class="line">    n_sum= array[<span class="number">0</span>] <span class="comment"># 到第i个数的最大累加和</span></span><br><span class="line">    sub_max = array[<span class="number">0</span>] <span class="comment"># 累加和end中的最大值</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        n_sum = array[i] <span class="keyword">if</span> n_sum &lt;= <span class="number">0</span> <span class="keyword">else</span> array[i] + n_sum</span><br><span class="line">        sub_max = n_sum <span class="keyword">if</span> n_sum &gt; sub_max <span class="keyword">else</span> sub_max</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> sub_max</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    array = list(map(int, input().strip().split(<span class="string">" "</span>)))</span><br><span class="line">    print(max_sub_array(array))</span><br></pre></td></tr></table></figure>
<p>求数组连续最大和，以及最大子数组的位置<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_sub_array_location</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    求数组连续最大和</span></span><br><span class="line"><span class="string">    :param array: 数组</span></span><br><span class="line"><span class="string">    :return: 数组连续最大和，最大子数组的位置</span></span><br><span class="line"><span class="string">    时间复杂度 O(N) 空间复杂度 O(1)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    n = len(array)</span><br><span class="line">    n_sum = <span class="number">0</span></span><br><span class="line">    sub_max = <span class="number">-2</span> ** <span class="number">31</span></span><br><span class="line">    start_location = <span class="number">0</span></span><br><span class="line">    end_location = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        <span class="comment"># 到第i个数的最大累加和</span></span><br><span class="line">        <span class="keyword">if</span> n_sum &lt;= <span class="number">0</span>:</span><br><span class="line">            n_sum = array[i]</span><br><span class="line">            start_location = i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            n_sum = array[i] + n_sum</span><br><span class="line">        <span class="comment"># 累加和end中的最大值</span></span><br><span class="line">        <span class="keyword">if</span> n_sum &gt; sub_max:</span><br><span class="line">            sub_max = n_sum</span><br><span class="line">            end_location = i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> (sub_max, start_location, end_location)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    array = list(map(int, input().strip().split(<span class="string">" "</span>)))</span><br><span class="line">    print(max_sub_array_location(array))</span><br></pre></td></tr></table></figure></p>
<h3 id="数组旋转"><a href="#数组旋转" class="headerlink" title="数组旋转"></a>数组旋转</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotateArray</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    逆时针旋转n*n矩阵45度</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    lens = len(array[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 打印二维数组的上半部分</span></span><br><span class="line">    i = lens - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">        col = i</span><br><span class="line">        <span class="keyword">while</span> col &lt; lens:</span><br><span class="line">            print(array[row][col], end=<span class="string">" "</span>)</span><br><span class="line">            row += <span class="number">1</span></span><br><span class="line">            col += <span class="number">1</span></span><br><span class="line">        print(<span class="string">""</span>)</span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">    <span class="comment"># 打印二维数组下半部分（包括对角线）</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; lens:</span><br><span class="line">        row = i</span><br><span class="line">        col = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> row &lt; lens:</span><br><span class="line">            print(array[row][col], end=<span class="string">" "</span>)</span><br><span class="line">            row += <span class="number">1</span></span><br><span class="line">            col += <span class="number">1</span></span><br><span class="line">        print(<span class="string">""</span>)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    array_row = int(input())</span><br><span class="line">    array = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(array_row):</span><br><span class="line">        array.append(list(map(int, input().strip().split(<span class="string">" "</span>))))</span><br><span class="line">    rotateArray(array)</span><br></pre></td></tr></table></figure>
<h3 id="判断区间-a-b-与-c-d-是否相交，如果相交那么相交部分的长度L是多少？"><a href="#判断区间-a-b-与-c-d-是否相交，如果相交那么相交部分的长度L是多少？" class="headerlink" title="判断区间[a, b]与[c, d]是否相交，如果相交那么相交部分的长度L是多少？"></a>判断区间[a, b]与[c, d]是否相交，如果相交那么相交部分的长度L是多少？</h3><p>如果区间相交，那么区间最大的开始端一定小于最小的结束端，且相交的长度就是最小结束端减去最大开始端的值。</p>
<script type="math/tex; mode=display">L = min(b, d) - max(a, c)</script><h3 id="找出数组中和为S的两个数字"><a href="#找出数组中和为S的两个数字" class="headerlink" title="找出数组中和为S的两个数字"></a>找出数组中和为S的两个数字</h3><ol>
<li>首先对数组进行排序，时间复杂度为（N*log2N）。</li>
<li>然后令i = 0，j = n-1，看arr[i] + arr[j] 是否等于Sum，如果是，则结束。如果小于Sum，则i = i + 1；如果大于Sum，则 j = j – 1。这样只需要在排好序的数组上遍历一次，就可以得到最后的结果，时间复杂度为O（N）。两步加起来总的时间复杂度O（N*log2N）</li>
</ol>
<p>找出数组中和为S的三个数字：首先还是先对数组进行排序，然后遍历数组元素arr[i]，找到和为S-arr[i]的两个数即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSumNumFromSortedList</span><span class="params">(sorted_list, target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(sorted_list) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        temp_sum = sorted_list[left] + sorted_list[right]</span><br><span class="line">        <span class="keyword">if</span> temp_sum == target:</span><br><span class="line">            <span class="keyword">return</span> [left, right]</span><br><span class="line">        <span class="keyword">elif</span> temp_sum &lt; target:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">"Non-existent!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    nums = list(map(int, input().strip().split()))</span><br><span class="line">    target = int(input())</span><br><span class="line">    print(getSumNumFromSortedList(nums, target))</span><br></pre></td></tr></table></figure>
<p>注意与“两数字和”区分：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">LeetCode 第 1 号问题：两数之和</span></span><br><span class="line"><span class="string">给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</span></span><br><span class="line"><span class="string">你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</span></span><br><span class="line"><span class="string">示例:</span></span><br><span class="line"><span class="string">给定 nums = [2, 7, 11, 15], target = 9</span></span><br><span class="line"><span class="string">因为 nums[0] + nums[1] = 2 + 7 = 9</span></span><br><span class="line"><span class="string">所以返回 [0, 1]</span></span><br><span class="line"><span class="string">时间复杂度 O(n) 空间复杂度  O(n)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twosum</span><span class="params">(num_list, target)</span>:</span></span><br><span class="line">    record = dict()</span><br><span class="line">    <span class="keyword">for</span> i, item <span class="keyword">in</span> enumerate(num_list):</span><br><span class="line">        complement = target - item</span><br><span class="line">        <span class="keyword">if</span> complement <span class="keyword">in</span> record:</span><br><span class="line">            <span class="keyword">return</span> [record[complement], i]</span><br><span class="line">        record[item] = i</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    nums = list(map(int, input().strip().split()))</span><br><span class="line">    target = int(input())</span><br><span class="line">    print(twosum(nums, target))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_two_odd_numbers_of_elements</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    找出数组中两个出现次数为奇数个数的数(这两个数不相等)</span></span><br><span class="line"><span class="string">    :param array: 整数数组</span></span><br><span class="line"><span class="string">    :return: (num1, num2) 数组中两个出现次数为奇数个数的元素</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># (item0 ^ item0)...a^b...(itemN^itemN) = a^b</span></span><br><span class="line">    a_xor_b = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> array:</span><br><span class="line">        a_xor_b ^= item</span><br><span class="line">    i = a_xor_b</span><br><span class="line">    <span class="comment"># 找到a和b二进制表示首次不相同的位置（从右往左），该位置的异或值为1</span></span><br><span class="line">    <span class="comment"># 异或值中一定存在1的证明：a!=b -&gt; a^b!=0 -&gt; 1 in bin(a_xor_b)</span></span><br><span class="line">    position = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">        position += <span class="number">1</span></span><br><span class="line">        i = i &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="comment"># 选取position位置都为1的元素来异或求值，这样a和b只会取到其中一个，</span></span><br><span class="line">    <span class="comment"># 其它数只会取到偶数个，而偶数个数的相同数异或值为0，0与x异或为x,</span></span><br><span class="line">    <span class="comment"># 故最终的异或值为 a 或 b</span></span><br><span class="line">    a_item = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> array:</span><br><span class="line">        item_positon = item &gt;&gt; position</span><br><span class="line">        <span class="keyword">if</span> (item_positon &amp; <span class="number">1</span>) == <span class="number">1</span>:</span><br><span class="line">            a_item ^= item</span><br><span class="line">    <span class="comment"># b = a ^ (a ^ b)</span></span><br><span class="line">    b_item = a_item ^ a_xor_b</span><br><span class="line">    <span class="keyword">return</span> (a_item, b_item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    array = list(map(int, input().strip().split()))</span><br><span class="line">    print(find_two_odd_numbers_of_elements(array))</span><br></pre></td></tr></table></figure>
<h3 id="寻找最多的覆盖点"><a href="#寻找最多的覆盖点" class="headerlink" title="寻找最多的覆盖点"></a>寻找最多的覆盖点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_cover</span><span class="params">(a, L)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    寻找最多的覆盖点</span></span><br><span class="line"><span class="string">    :param a: 长度为n的数组，表示坐标轴上从左到右的点a[0],a[1],...,a[n-1]</span></span><br><span class="line"><span class="string">    :param L: 木棒长度L</span></span><br><span class="line"><span class="string">    :return: 木棒最多能覆盖的坐标轴点的个数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    count = <span class="number">2</span></span><br><span class="line">    max_count = <span class="number">1</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    n = len(a)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &lt; n:</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n) <span class="keyword">and</span> (a[j] - a[i] &lt;= L):</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        j -= <span class="number">1</span></span><br><span class="line">        count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count &gt; max_count:</span><br><span class="line">            start = i</span><br><span class="line">            max_count = count</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 输出覆盖的节点</span></span><br><span class="line">    <span class="comment"># i = start</span></span><br><span class="line">    <span class="comment"># while i &lt; start + max_count:</span></span><br><span class="line">    <span class="comment">#     print(a[i])</span></span><br><span class="line">    <span class="comment">#     i += 1</span></span><br><span class="line">    <span class="keyword">return</span> max_count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = list(map(int, input().split()))  <span class="comment"># 7 8 10 11 12 13 15 16 17 19 25</span></span><br><span class="line">    L = int(input())  <span class="comment"># 8</span></span><br><span class="line">    print(max_cover(a, L))  <span class="comment"># 7</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串匹配之KMP算法"><a href="#字符串匹配之KMP算法" class="headerlink" title="字符串匹配之KMP算法"></a>字符串匹配之KMP算法</h3><p><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">字符串匹配的KMP算法</a></p>
<p><a href="https://www.jianshu.com/p/dcfa55a773f0" target="_blank" rel="noopener">图解kmp算法-通俗易懂kmp算法</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmp</span><span class="params">(S, P)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    knut-Morris-Pratt String Matching Algorithms</span></span><br><span class="line"><span class="string">    :param S: Source string</span></span><br><span class="line"><span class="string">    :param P: Pattern string</span></span><br><span class="line"><span class="string">    :return: Matching position</span></span><br><span class="line"><span class="string">    时间复杂度 O(len(S)+len(P))</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_next</span><span class="params">(P, P_length)</span>:</span></span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        next_list = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(P_length)]</span><br><span class="line">        next_list[<span class="number">0</span>] = k</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, P_length):</span><br><span class="line">            <span class="keyword">while</span> k &gt; <span class="number">0</span> <span class="keyword">and</span> P[k] != P[i]:</span><br><span class="line">                k = next_list[k - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> P[k] == P[i]:</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">            next_list[i] = k</span><br><span class="line">        <span class="keyword">return</span> next_list</span><br><span class="line"></span><br><span class="line">    S_len = len(S)</span><br><span class="line">    P_len = len(P)</span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    next_list = _next(P, P_len)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(S_len):</span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">0</span> <span class="keyword">and</span> P[k] != S[i]:</span><br><span class="line">            k = next_list[k - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> P[k] == S[i]:</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k == P_len:</span><br><span class="line">            <span class="keyword">return</span> i - k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    S = <span class="string">"dabxabxababxabwabxad"</span></span><br><span class="line">    P = <span class="string">"abxabwabxad"</span></span><br><span class="line">    location = kmp(S, P)</span><br><span class="line">    print(location)</span><br></pre></td></tr></table></figure>
<h3 id="编辑距离算法"><a href="#编辑距离算法" class="headerlink" title="编辑距离算法"></a>编辑距离算法</h3><p><a href="https://blog.csdn.net/qq_41359051/article/details/86623571" target="_blank" rel="noopener">动态规划-用编辑距离解释</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">editorial_distance</span><span class="params">(strA, strB)</span>:</span></span><br><span class="line">	strA_length = len(strA)</span><br><span class="line">	strB_length = len(strB)</span><br><span class="line">	distance_array = [[<span class="number">0</span>] * (strB_length+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(strA_length+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(strA_length+<span class="number">1</span>):</span><br><span class="line">		distance_array[i][<span class="number">0</span>] = i</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> range(strB_length+<span class="number">1</span>):</span><br><span class="line">		distance_array[<span class="number">0</span>][j] = j</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, strA_length+<span class="number">1</span>):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, strB_length+<span class="number">1</span>):</span><br><span class="line">			<span class="keyword">if</span> strA[i<span class="number">-1</span>] == strB[j<span class="number">-1</span>]:</span><br><span class="line">				distance_array[i][j] = distance_array[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">			<span class="keyword">else</span>: <span class="comment"># 在插入、删除、替换操作中保留最优解</span></span><br><span class="line">				distance_array[i][j] = min([distance_array[i<span class="number">-1</span>][j]+<span class="number">1</span>,  distance_array[i][j<span class="number">-1</span>]+<span class="number">1</span>, distance_array[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> distance_array[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">	strA = <span class="string">"mouuse"</span></span><br><span class="line">	strB = <span class="string">"mouse"</span></span><br><span class="line">	print(editorial_distance(strA, strB))</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20190124112735774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzU5MDUx,size_16,color_FFFFFF,t_70" alt=""></p>
<h3 id="Leetcode-583-两个字符串的删除操作"><a href="#Leetcode-583-两个字符串的删除操作" class="headerlink" title="Leetcode 583. 两个字符串的删除操作"></a>Leetcode <a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/" target="_blank" rel="noopener">583. 两个字符串的删除操作</a></h3><blockquote>
<p>为了求得最少删除次数，我们可以求出串 s1 和串 s2 最长公共子序列，我们记为 lcs。如果我们能求得 lcs 的值，我们可以轻易地求出答案，为 m + n - 2*lcs。这里 m 和 n 分别是给定字符串 s1s1 和 s2s2 的长度。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    时间复杂度：O(m*n)。我们需要填充大小为m * n的数组dp。m和n分别是s1和s2字符串的长度。</span></span><br><span class="line"><span class="string">    空间复杂度：O(m*n)。使用了大小为m∗n的dp数组。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        word1 = <span class="string">"#"</span> + word1</span><br><span class="line">        word2 = <span class="string">"#"</span> + word2</span><br><span class="line">        dp_matrix = [[<span class="number">0</span>] * len(word2) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word1))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(word1)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(word2)):</span><br><span class="line">                <span class="keyword">if</span> word1[i] == word2[j]:</span><br><span class="line">                    dp_matrix[i][j] = dp_matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp_matrix[i][j] = max(dp_matrix[i - <span class="number">1</span>][j], dp_matrix[i][j - <span class="number">1</span>])</span><br><span class="line">        longest_common_sequence_length = dp_matrix[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> len(word1) + len(word2) - <span class="number">2</span> * longest_common_sequence_length - <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><ul>
<li><a href="https://blog.csdn.net/weixin_40673608/article/details/84262695" target="_blank" rel="noopener">动态规划解最长公共子序列(LCS)(附详细填表过程)</a></li>
<li><a href="https://blog.csdn.net/so_geili/article/details/53737001" target="_blank" rel="noopener">算法导论——-最长公共子序列LCS（动态规划）</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_longest_common_sequence_path</span><span class="params">(path_matrix, X_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param path_matrix: 动态规划矩阵</span></span><br><span class="line"><span class="string">    :param X_list: 其中一个字符串</span></span><br><span class="line"><span class="string">    :return: 最长公共子序列路径</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    result_list = list()</span><br><span class="line">    i = len(path_matrix) - <span class="number">1</span></span><br><span class="line">    j = len(path_matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> path_matrix[i][j] != <span class="string">"0"</span>:</span><br><span class="line">        <span class="keyword">if</span> path_matrix[i][j] == <span class="string">"left_upper"</span>:</span><br><span class="line">            result_list.append(X_list[i])</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> path_matrix[i][j] == <span class="string">"upper"</span>:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    result_list.reverse()</span><br><span class="line">    <span class="keyword">return</span> result_list</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longest_common_sequence</span><span class="params">(X_list, Y_list)</span>:</span></span><br><span class="line">    X_list.insert(<span class="number">0</span>, <span class="string">""</span>)</span><br><span class="line">    Y_list.insert(<span class="number">0</span>, <span class="string">""</span>)</span><br><span class="line">    dp_matrix = [[<span class="number">0</span>] * len(Y_list) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(X_list))]</span><br><span class="line">    path_matrix = [[<span class="string">"0"</span>] * len(Y_list) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(X_list))]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(X_list)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(Y_list)):</span><br><span class="line">            <span class="keyword">if</span> X_list[i] == Y_list[j]:</span><br><span class="line">                dp_matrix[i][j] = dp_matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                path_matrix[i][j] = <span class="string">"left_upper"</span></span><br><span class="line">            <span class="keyword">elif</span> dp_matrix[i - <span class="number">1</span>][j] &gt;= dp_matrix[i][j - <span class="number">1</span>]:</span><br><span class="line">                dp_matrix[i][j] = dp_matrix[i - <span class="number">1</span>][j]</span><br><span class="line">                path_matrix[i][j] = <span class="string">"upper"</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp_matrix[i][j] = dp_matrix[i][j - <span class="number">1</span>]</span><br><span class="line">                path_matrix[i][j] = <span class="string">"left"</span></span><br><span class="line">    longest_common_sequence_length = dp_matrix[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line">    longest_common_sequence_path = get_longest_common_sequence_path(path_matrix, X_list)</span><br><span class="line">    <span class="keyword">return</span> longest_common_sequence_path</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    X_list = list(<span class="string">"ACCGGTCGAGTGCGCGGAAGCCGGCCGAA"</span>)</span><br><span class="line">    Y_list = list(<span class="string">"GTCGTTCGGAATGCCGTTGCTCTGTAAA"</span>)</span><br><span class="line">    longest_common_sequence_path = longest_common_sequence(X_list,Y_list)</span><br><span class="line">    <span class="comment"># "G,T,C,G,T,C,G,G,A,A,G,C,C,G,G,C,C,G,A,A"</span></span><br><span class="line">    print(<span class="string">","</span>.join(longest_common_sequence_path))</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-718-最长重复子数组"><a href="#Leetcode-718-最长重复子数组" class="headerlink" title="Leetcode 718. 最长重复子数组"></a>Leetcode <a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/submissions/" target="_blank" rel="noopener">718. 最长重复子数组</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLength</span><span class="params">(self, A: List[int], B: List[int])</span> -&gt; int:</span></span><br><span class="line">        A.insert(<span class="number">0</span>, <span class="string">""</span>)</span><br><span class="line">        B.insert(<span class="number">0</span>, <span class="string">""</span>)</span><br><span class="line">        A_len = len(A)</span><br><span class="line">        B_len = len(B)</span><br><span class="line">        dp_matrix = [[<span class="number">0</span>] * (B_len) <span class="keyword">for</span> _ <span class="keyword">in</span> range(A_len)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, A_len):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, B_len):</span><br><span class="line">                <span class="keyword">if</span> A[i] == B[j]:</span><br><span class="line">                    dp_matrix[i][j] = dp_matrix[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(max(row) <span class="keyword">for</span> row <span class="keyword">in</span> dp_matrix)</span><br></pre></td></tr></table></figure>
<h3 id="最长公共连续子字符串"><a href="#最长公共连续子字符串" class="headerlink" title="最长公共连续子字符串"></a>最长公共连续子字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longest_common_continuous_substring</span><span class="params">(A_str, B_str)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    最长公共连续子字符串</span></span><br><span class="line"><span class="string">    :param A_str: 字符串A，长度为m</span></span><br><span class="line"><span class="string">    :param B_str: 字符串B，长度为n</span></span><br><span class="line"><span class="string">    :return: 字符串A和字符串B公共的连续最长的字符串列表</span></span><br><span class="line"><span class="string">    时间复杂度：O(m*n) 空间复杂度：O(m*n)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    A_str = <span class="string">"#"</span> + A_str</span><br><span class="line">    B_str = <span class="string">"#"</span> + B_str</span><br><span class="line">    A_str_len = len(A_str)</span><br><span class="line">    B_str_len = len(B_str)</span><br><span class="line">    dp_matrix = [[<span class="number">0</span>] * (B_str_len) <span class="keyword">for</span> _ <span class="keyword">in</span> range(A_str_len)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, A_str_len):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, B_str_len):</span><br><span class="line">            <span class="keyword">if</span> A_str[i] == B_str[j]:</span><br><span class="line">                dp_matrix[i][j] = dp_matrix[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    substring_max_length_list = [max(row) <span class="keyword">for</span> row <span class="keyword">in</span> dp_matrix]</span><br><span class="line">    substring_max_length = max(substring_max_length_list)</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> idx, num <span class="keyword">in</span> enumerate(substring_max_length_list):</span><br><span class="line">        <span class="keyword">if</span> num == substring_max_length:</span><br><span class="line">            result.append(A_str[idx - num + <span class="number">1</span>:idx + <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    A_str = <span class="string">"ABCBDEFBWD"</span></span><br><span class="line">    B_str = <span class="string">"BCBWD"</span></span><br><span class="line">    <span class="comment"># ['BCB', 'BWD']</span></span><br><span class="line">    print(longest_common_continuous_substring(A_str, B_str))</span><br></pre></td></tr></table></figure>
<h3 id="Trie树（字典树，单词查找树）"><a href="#Trie树（字典树，单词查找树）" class="headerlink" title="Trie树（字典树，单词查找树）"></a>Trie树（字典树，单词查找树）</h3><ul>
<li>Trie树实现  <a href="https://github.com/hankcs/pyhanlp/blob/master/tests/book/ch02/trie.py" target="_blank" rel="noopener">https://github.com/hankcs/pyhanlp/blob/master/tests/book/ch02/trie.py</a></li>
<li>Trie树理论知识 <a href="https://www.cnblogs.com/lisen10/p/10922670.html" target="_blank" rel="noopener">数据结构与算法—Trie树</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self._children = &#123;&#125;</span><br><span class="line">        self._value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_add_child</span><span class="params">(self, char, value, overwrite=False)</span>:</span></span><br><span class="line">        child = self._children.get(char)</span><br><span class="line">        <span class="keyword">if</span> child <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            child = Node(value)</span><br><span class="line">            self._children[char] = child</span><br><span class="line">        <span class="keyword">elif</span> overwrite:</span><br><span class="line">            child._value = value</span><br><span class="line">        <span class="keyword">return</span> child</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span><span class="params">(Node)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        super().__init__(<span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self[key] <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        state = self</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> key:</span><br><span class="line">            state = state._children.get(char)</span><br><span class="line">            <span class="keyword">if</span> state <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> state._value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        state = self</span><br><span class="line">        <span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(key):</span><br><span class="line">            <span class="keyword">if</span> i &lt; len(key) - <span class="number">1</span>:</span><br><span class="line">                state = state._add_child(char, <span class="keyword">None</span>, <span class="keyword">False</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                state = state._add_child(char, value, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    trie = Trie()</span><br><span class="line">    <span class="comment"># 增</span></span><br><span class="line">    trie[<span class="string">'自然'</span>] = <span class="string">'nature'</span></span><br><span class="line">    trie[<span class="string">'自然人'</span>] = <span class="string">'human'</span></span><br><span class="line">    trie[<span class="string">'自然语言'</span>] = <span class="string">'language'</span></span><br><span class="line">    trie[<span class="string">'自语'</span>] = <span class="string">'talk	to oneself'</span></span><br><span class="line">    trie[<span class="string">'入门'</span>] = <span class="string">'introduction'</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="string">'自然'</span> <span class="keyword">in</span> trie</span><br><span class="line">    <span class="comment"># 删</span></span><br><span class="line">    trie[<span class="string">'自然'</span>] = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="string">'自然'</span> <span class="keyword">not</span> <span class="keyword">in</span> trie</span><br><span class="line">    <span class="comment"># 改</span></span><br><span class="line">    trie[<span class="string">'自然语言'</span>] = <span class="string">'human language'</span></span><br><span class="line">    <span class="keyword">assert</span> trie[<span class="string">'自然语言'</span>] == <span class="string">'human language'</span></span><br><span class="line">    <span class="comment"># 查</span></span><br><span class="line">    <span class="keyword">assert</span> trie[<span class="string">'入门'</span>] == <span class="string">'introduction'</span></span><br></pre></td></tr></table></figure>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输入：</span></span><br><span class="line"><span class="string">第一行表示表示用户互动矩阵的行数（用户个数）</span></span><br><span class="line"><span class="string">矩阵（i, j）的每一个值表示用户i与j互动的次数，当次数大于3时互为豆油瓶。</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">矩阵对应的豆油瓶个数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">例子1：</span></span><br><span class="line"><span class="string">输入：</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">0 4 0</span></span><br><span class="line"><span class="string">4 0 0</span></span><br><span class="line"><span class="string">0 0 0</span></span><br><span class="line"><span class="string">输出：（用户1和2互动次数超过3次，互为豆油瓶，用户3没有互动，自成一个豆油瓶）</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    并查集解法</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDouYouNum</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> array:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(array[<span class="number">0</span>])</span><br><span class="line">        self.count = n</span><br><span class="line">        self.father_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        self.size_list = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> array[i][j] &gt;= <span class="number">3</span>:</span><br><span class="line">                    self.union(i, j)</span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">while</span>(i != self.father_list[i]):</span><br><span class="line">            i = self.father_list[i]</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        p = self.find(i)</span><br><span class="line">        q = self.find(j)</span><br><span class="line">        <span class="keyword">if</span> p == q:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.size_list[p] &lt; self.size_list[q]:</span><br><span class="line">            self.father_list[p] = q</span><br><span class="line">            self.size_list[q] += self.size_list[p]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.father_list[q] = p</span><br><span class="line">            self.size_list[p] += self.size_list[q]</span><br><span class="line">        self.count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    n = int(input())</span><br><span class="line">    array = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        array[i] = list(map(int, input().strip().split(<span class="string">" "</span>)))</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.findDouYouNum(array))</span><br></pre></td></tr></table></figure>
<h3 id="2048小游戏"><a href="#2048小游戏" class="headerlink" title="2048小游戏"></a>2048小游戏</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">2048合并规则：</span></span><br><span class="line"><span class="string">1. 相邻会碰撞的两个相同数字合并且只会触发一次合并；</span></span><br><span class="line"><span class="string">2. 优先合并移动方向顶部的位置，比如 [2, 2 ,2 , 2] 行向右合并为 [0, 0, 4, 4]</span></span><br><span class="line"><span class="string">输入：</span></span><br><span class="line"><span class="string">第1行是2048块的滑动方向键。1：上、2：下、3：左、4：右。</span></span><br><span class="line"><span class="string">接下来4 x 4的数字矩阵用空格分割，0表示该位置没有数字。</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">用户按下房间键红后的矩阵值。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">示例</span></span><br><span class="line"><span class="string">输入：</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">0 0 0 2</span></span><br><span class="line"><span class="string">0 0 0 2</span></span><br><span class="line"><span class="string">0 0 4 8</span></span><br><span class="line"><span class="string">0 0 4 8</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">0 0 8 4</span></span><br><span class="line"><span class="string">0 0 0 16</span></span><br><span class="line"><span class="string">0 0 0 0</span></span><br><span class="line"><span class="string">0 0 0 0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MoveUp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">4</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> Num[i][j] != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(i+<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">                <span class="keyword">if</span> Num[k][j] != <span class="number">0</span>:</span><br><span class="line">                    Num[i][j], Num[k][j] = Num[k][j], Num[i][j]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MoveDown</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">4</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> Num[i][j] != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(i<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> Num[k][j] != <span class="number">0</span>:</span><br><span class="line">                    Num[i][j], Num[k][j] = Num[k][j], Num[i][j]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MoveLeft</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">4</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> Num[i][j] != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(j+<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">                <span class="keyword">if</span> Num[i][k] != <span class="number">0</span>:</span><br><span class="line">                    Num[i][j], Num[i][k] = Num[i][k], Num[i][j]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MoveRight</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">4</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> Num[i][j] != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(j<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> Num[i][k] != <span class="number">0</span>:</span><br><span class="line">                    Num[i][j], Num[i][k] = Num[i][k], Num[i][j]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(direction)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> direction == <span class="number">1</span>:</span><br><span class="line">        MoveUp()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">4</span>):</span><br><span class="line">                <span class="keyword">if</span> Num[i][j] == Num[i + <span class="number">1</span>][j]:</span><br><span class="line">                    Num[i][j] &lt;&lt;= <span class="number">1</span></span><br><span class="line">                    Num[i + <span class="number">1</span>][j] = <span class="number">0</span></span><br><span class="line">        MoveUp()</span><br><span class="line">    <span class="keyword">elif</span> direction == <span class="number">2</span>:</span><br><span class="line">        MoveDown()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">4</span>):</span><br><span class="line">                <span class="keyword">if</span> Num[i][j] == Num[i - <span class="number">1</span>][j]:</span><br><span class="line">                    Num[i][j] &lt;&lt;= <span class="number">1</span></span><br><span class="line">                    Num[i - <span class="number">1</span>][j] = <span class="number">0</span></span><br><span class="line">        MoveDown()</span><br><span class="line">    <span class="keyword">elif</span> direction == <span class="number">3</span>:</span><br><span class="line">        MoveRight()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">4</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> Num[i][j] == Num[i][j - <span class="number">1</span>]:</span><br><span class="line">                    Num[i][j] &lt;&lt;= <span class="number">1</span></span><br><span class="line">                    Num[i][j - <span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        MoveRight()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        MoveLeft()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">4</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span> Num[i][j] == Num[i][j - <span class="number">1</span>]:</span><br><span class="line">                    Num[i][j] &lt;&lt;= <span class="number">1</span></span><br><span class="line">                    Num[i][j - <span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        MoveLeft()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    direction = int(input())</span><br><span class="line">    Num = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        Num[i] = list(map(int, input().strip().split()))</span><br><span class="line">    move(direction)</span><br><span class="line">    print(Num)</span><br></pre></td></tr></table></figure>
<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(heights)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Leetcode 84：柱状图中最大的矩形</span></span><br><span class="line"><span class="string">    :type heights: List[int]</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    stack = list()</span><br><span class="line">    res, i = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(heights):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> heights[i] &gt;= heights[stack[<span class="number">-1</span>]]:</span><br><span class="line">            stack.append(i)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = stack.pop()</span><br><span class="line">            current_s = heights[k] * ((i - stack[<span class="number">-1</span>] - <span class="number">1</span>) <span class="keyword">if</span> stack <span class="keyword">else</span> i)</span><br><span class="line">            res = max(res, current_s)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        k = stack.pop()</span><br><span class="line">        current_s = heights[k] * ((i - stack[<span class="number">-1</span>] - <span class="number">1</span>) <span class="keyword">if</span> stack <span class="keyword">else</span> i)</span><br><span class="line">        res = max(res, current_s)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    heights = list(map(int, input().split(<span class="string">" "</span>)))</span><br><span class="line">    print(largestRectangleArea(heights))</span><br></pre></td></tr></table></figure>
<h3 id="迷宫"><a href="#迷宫" class="headerlink" title="迷宫"></a>迷宫</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Maze</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    给定N*M的迷宫，需要走左上角走到右下角，只能向右或者向下移动。</span></span><br><span class="line"><span class="string">    在迷宫中0表示没有路，1表示有路。是否存在一条可行的路径？</span></span><br><span class="line"><span class="string">    例子：</span></span><br><span class="line"><span class="string">    迷宫行数（列数）4</span></span><br><span class="line"><span class="string">    迷宫</span></span><br><span class="line"><span class="string">    1 0 0 0</span></span><br><span class="line"><span class="string">    1 1 0 1</span></span><br><span class="line"><span class="string">    0 1 0 0</span></span><br><span class="line"><span class="string">    1 1 1 1</span></span><br><span class="line"><span class="string">    解法</span></span><br><span class="line"><span class="string">    1 0 0 0</span></span><br><span class="line"><span class="string">    1 1 0 0</span></span><br><span class="line"><span class="string">    0 1 0 0</span></span><br><span class="line"><span class="string">    0 1 1 1</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, maze)</span>:</span></span><br><span class="line">        self.maze = maze <span class="comment"># 迷宫</span></span><br><span class="line">        self.N = len(maze)</span><br><span class="line">        self.sol = [[<span class="number">0</span>] * self.N <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.N)] <span class="comment"># 存储结果</span></span><br><span class="line">    <span class="comment"># 打印从起点到终点的路线</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_solution_matrix</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.N):</span><br><span class="line">            print(<span class="string">" "</span>.join(map(str, self.sol[i])))</span><br><span class="line">    <span class="comment"># 判断x和y是否是一个合理的单元</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_safe</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> <span class="keyword">and</span> x &lt; self.N <span class="keyword">and</span> y &gt;= <span class="number">0</span> <span class="keyword">and</span> y &lt; self.N \</span><br><span class="line">               <span class="keyword">and</span> self.maze[x][y] == <span class="number">1</span></span><br><span class="line">    <span class="comment"># 使用回溯的方法找到一条从左上角到右下角的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_path</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="comment"># 达到目的地</span></span><br><span class="line">        <span class="keyword">if</span> x == self.N - <span class="number">1</span> <span class="keyword">and</span> y == self.N - <span class="number">1</span>:</span><br><span class="line">            self.sol[x][y] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="comment"># 判断maze[x][y]是否是一个可走的单元</span></span><br><span class="line">        <span class="keyword">if</span> self.is_safe(x, y):</span><br><span class="line">            <span class="comment"># 标记当前单元为1，表示可走</span></span><br><span class="line">            self.sol[x][y] = <span class="number">1</span></span><br><span class="line">            <span class="comment"># 向右走一步</span></span><br><span class="line">            <span class="keyword">if</span> self.get_path(x + <span class="number">1</span>, y):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="comment"># 向下走一步</span></span><br><span class="line">            <span class="keyword">if</span> self.get_path(x, y + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="comment"># 标记当前单元为0，表示这条路不可行，然后回溯</span></span><br><span class="line">            self.sol[x][y] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n = int(input())</span><br><span class="line">    maze = list()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">        maze.append(list(map(int, input().split())))</span><br><span class="line"></span><br><span class="line">    rat = Maze(maze)</span><br><span class="line">    <span class="keyword">if</span> rat.get_path(<span class="number">0</span>, <span class="number">0</span>):</span><br><span class="line">        rat.print_solution_matrix()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"不存在可达路径"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">schedule</span><span class="params">(R, O, M)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    给定一台有M个存储空间的机器，有n个请求需要在这台机器上运行，</span></span><br><span class="line"><span class="string">    第i个请求计算需要占用R[i]的空间，计算结果需要占O[i]个空间（O[i]&lt;R[i]）。</span></span><br><span class="line"><span class="string">    判断这n个请求是否能全部完成？若能，给出这个n个请求的按排顺序。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 按照 R[i] - O[i] 由大到小进行排序</span></span><br><span class="line">    <span class="comment"># 可以使用归纳法证明，按照这个顺序执行的成功可能性最大。</span></span><br><span class="line">    R_O = list(zip(R, O))</span><br><span class="line">    R_O.sort(key=<span class="keyword">lambda</span> item: -(item[<span class="number">0</span>] - item[<span class="number">1</span>]))</span><br><span class="line">    R = [item[<span class="number">0</span>] <span class="keyword">for</span> item <span class="keyword">in</span> R_O]</span><br><span class="line">    O = [item[<span class="number">1</span>] <span class="keyword">for</span> item <span class="keyword">in</span> R_O]</span><br><span class="line">    left = M  <span class="comment"># 剩余可用的空间数</span></span><br><span class="line">    lens = len(R)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; lens:</span><br><span class="line">        <span class="keyword">if</span> left &lt; R[i]:  <span class="comment"># 剩余的空间无法继续处理第i个请求</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 剩余的空间能继续处理第i个请求，处理完后将占用O[i]个空间</span></span><br><span class="line">            left -= O[i]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    print(<span class="string">"按照如下请求序列可以完成："</span>)</span><br><span class="line">    print(R_O)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n = int(input())  <span class="comment"># 8</span></span><br><span class="line">    M = int(input())  <span class="comment"># 50</span></span><br><span class="line">    R = list(map(int, input().split()))  <span class="comment"># 10 15 23 20 6 9 7 16</span></span><br><span class="line">    O = list(map(int, input().split()))  <span class="comment"># 2 7 8 4 5 8 6 8</span></span><br><span class="line">    print(schedule(R, O, M))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<h3 id="leetcode873-最长的斐波那契子序列的长度"><a href="#leetcode873-最长的斐波那契子序列的长度" class="headerlink" title="leetcode873. 最长的斐波那契子序列的长度"></a>leetcode873. 最长的斐波那契子序列的长度</h3><ul>
<li><a href="https://coordinate.wang/index.php/archives/2098/" target="_blank" rel="noopener">https://coordinate.wang/index.php/archives/2098/</a></li>
<li><a href="https://blog.csdn.net/weixin_37373020/article/details/81559842" target="_blank" rel="noopener">https://blog.csdn.net/weixin_37373020/article/details/81559842</a></li>
</ul>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p><a href="https://github.com/tianyicui/pack/blob/master/V2.pdf" target="_blank" rel="noopener">背包问题九讲 催添翼</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zero_one_bag_problem</span><span class="params">(bag_v, n_weight, n_vol)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    零一背包问题</span></span><br><span class="line"><span class="string">    :param bag_v: 背包体积</span></span><br><span class="line"><span class="string">    :param n_weight: 物品价值</span></span><br><span class="line"><span class="string">    :param n_vol: 物品体积</span></span><br><span class="line"><span class="string">    :return: 包能装的物品最大总价值</span></span><br><span class="line"><span class="string">    时间复杂度 O(NV)，空间复杂度O(NV)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 填充没有价值的物品</span></span><br><span class="line">    n_weight.insert(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    n_vol.insert(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    array = [[<span class="number">0</span>] * (bag_v + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(n_weight))]</span><br><span class="line">    <span class="comment"># 遍历物品N</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(n_weight)):</span><br><span class="line">        <span class="comment"># 遍历不同被包容量V</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, bag_v + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 如果当前背包容量不能够装下第i件物品</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; n_vol[i]:</span><br><span class="line">                array[i][j] = array[i - <span class="number">1</span>][j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                array[i][j] = max(array[i - <span class="number">1</span>][j], array[i - <span class="number">1</span>][j - n_vol[i]] + n_weight[i])</span><br><span class="line">    <span class="comment"># 打印运算过程</span></span><br><span class="line">    <span class="comment"># for i in range(len(n_weight)):</span></span><br><span class="line">    <span class="comment">#     print(array[i])</span></span><br><span class="line">    <span class="keyword">return</span> array[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    bag_v = int(input())  <span class="comment"># 12</span></span><br><span class="line">    n_vol = list(map(int, input().strip().split(<span class="string">" "</span>)))  <span class="comment"># 1 3 2 6 2</span></span><br><span class="line">    n_weight = list(map(int, input().strip().split(<span class="string">" "</span>)))  <span class="comment"># 2 5 3 10 4</span></span><br><span class="line">    print(zero_one_bag_problem(bag_v, n_weight, n_vol))  <span class="comment"># 21</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zero_one_bag_problem</span><span class="params">(bag_v, n_weight, n_vol)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    零一背包问题</span></span><br><span class="line"><span class="string">    :param bag_v: 背包体积</span></span><br><span class="line"><span class="string">    :param n_weight: 物品价值</span></span><br><span class="line"><span class="string">    :param n_vol: 物品体积</span></span><br><span class="line"><span class="string">    :return: 包能装的物品最大总价值</span></span><br><span class="line"><span class="string">    时间复杂度 O(NV)，空间复杂度O(V)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    array = [<span class="number">0</span>] * (bag_v + <span class="number">1</span>) <span class="comment"># 填充0，方便表示</span></span><br><span class="line">    <span class="comment"># 依次遍历每个物品N</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(n_vol)):</span><br><span class="line">        <span class="comment"># 从大到小遍历遍历背包容量V（当背包容量小于物品容量时直接跳过）</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(bag_v, n_vol[i] - <span class="number">1</span>, <span class="number">-1</span>):</span><br><span class="line">                array[j] = max(array[j], array[j-n_vol[i]] + n_weight[i])</span><br><span class="line">    <span class="keyword">return</span> array[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    bag_v = int(input())  <span class="comment"># 12</span></span><br><span class="line">    n_vol = list(map(int, input().strip().split(<span class="string">" "</span>)))  <span class="comment"># 1 3 2 6 2</span></span><br><span class="line">    n_weight = list(map(int, input().strip().split(<span class="string">" "</span>)))  <span class="comment"># 2 5 3 10 4</span></span><br><span class="line">    print(zero_one_bag_problem(bag_v, n_weight, n_vol))  <span class="comment"># 21</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">full_bag_problem</span><span class="params">(bag_v, n_weight, n_vol)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    完全背包问题</span></span><br><span class="line"><span class="string">    :param bag_v: 背包体积</span></span><br><span class="line"><span class="string">    :param n_weight: 物品价值</span></span><br><span class="line"><span class="string">    :param n_vol: 物品体积</span></span><br><span class="line"><span class="string">    :return: 包能装的物品最大总价值</span></span><br><span class="line"><span class="string">    时间复杂度 O(NV)，空间复杂度O(V)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    array = [<span class="number">0</span>] * (bag_v + <span class="number">1</span>) <span class="comment"># 填充0，方便表示</span></span><br><span class="line">    <span class="comment"># 依次遍历每个物品N</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(n_vol)):</span><br><span class="line">        <span class="comment"># 从大到小遍历遍历背包容量V（当背包容量小于物品容量时直接跳过）</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n_vol[i], bag_v + <span class="number">1</span>):</span><br><span class="line">                array[j] = max(array[j], array[j-n_vol[i]] + n_weight[i])</span><br><span class="line">    <span class="keyword">return</span> array[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    bag_v = int(input())  <span class="comment"># 15</span></span><br><span class="line">    n_vol = list(map(int, input().strip().split(<span class="string">" "</span>)))  <span class="comment"># 5 4 7 2 6</span></span><br><span class="line">    n_weight = list(map(int, input().strip().split(<span class="string">" "</span>)))  <span class="comment"># 12 3 10 3 6</span></span><br><span class="line">    print(complete_bag_problem(bag_v, n_weight, n_vol))  <span class="comment"># 36</span></span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-416：分割等和子集"><a href="#Leetcode-416：分割等和子集" class="headerlink" title="Leetcode 416：分割等和子集"></a>Leetcode 416：分割等和子集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        size = len(nums)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 特判，如果整个数组的和都不是偶数，就无法平分</span></span><br><span class="line">        s = sum(nums)</span><br><span class="line">        <span class="keyword">if</span> s &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二维 dp 问题：背包的容量</span></span><br><span class="line">        target = s // <span class="number">2</span></span><br><span class="line">        dp = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(target + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(size)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先写第 1 行：看看第 1 个数是不是能够刚好填满容量为 target</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(target + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="keyword">False</span> <span class="keyword">if</span> nums[<span class="number">0</span>] != i <span class="keyword">else</span> <span class="keyword">True</span></span><br><span class="line">        <span class="comment"># i 表示物品索引</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, size):</span><br><span class="line">            <span class="comment"># j 表示容量</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(target + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= nums[i]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] <span class="keyword">or</span> dp[i - <span class="number">1</span>][j - nums[i]]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    nums = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">5</span>]</span><br><span class="line">    print(Solution().canPartition(nums))</span><br></pre></td></tr></table></figure>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>当数组“有序”时，考虑用二分查找。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search_recursion</span><span class="params">(lst, val, start, end)</span>:</span></span><br><span class="line">    <span class="comment">#递归二分查找</span></span><br><span class="line">    <span class="keyword">if</span> start &gt; end:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    mid = (start + end) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> lst[mid] &lt; val:</span><br><span class="line">        <span class="keyword">return</span> binary_search_recursion(lst, val, mid + <span class="number">1</span>, end)</span><br><span class="line">    <span class="keyword">if</span> lst[mid] &gt; val:</span><br><span class="line">        <span class="keyword">return</span> binary_search_recursion(lst, val, start, mid - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search_loop</span><span class="params">(lst, val)</span>:</span></span><br><span class="line">    <span class="comment">#循环二分查找</span></span><br><span class="line">    start, end = <span class="number">0</span>, len(lst) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> lst[mid] &lt; val:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> lst[mid] &gt; val:</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<h3 id="二分插入和查询算法（Python源码）"><a href="#二分插入和查询算法（Python源码）" class="headerlink" title="二分插入和查询算法（Python源码）"></a>二分插入和查询算法（Python源码）</h3><p>结论：二分查找最大比较次数为$\lfloor log_2(len(array)) \rfloor + 1$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line"><span class="string">"""Bisection algorithms."""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insort_right</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="string">"""Insert item x in list a, and keep it sorted assuming a is sorted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If x is already in a, insert it to the right of the rightmost x.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; a[mid]: hi = mid <span class="comment"># Limit high-end</span></span><br><span class="line">        <span class="keyword">else</span>: lo = mid+<span class="number">1</span></span><br><span class="line">    a.insert(lo, x)</span><br><span class="line"></span><br><span class="line">insort = insort_right   <span class="comment"># backward compatibility</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bisect_right</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="string">"""Return the index where to insert item x in list a, assuming a is sorted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The return value i is such that all e in a[:i] have e &lt;= x, and all e in</span></span><br><span class="line"><span class="string">    a[i:] have e &gt; x.  So if x already appears in the list, a.insert(x) will</span></span><br><span class="line"><span class="string">    insert just after the rightmost x already there.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; a[mid]: hi = mid <span class="comment"># Limit high-end</span></span><br><span class="line">        <span class="keyword">else</span>: lo = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> lo</span><br><span class="line"></span><br><span class="line">bisect = bisect_right   <span class="comment"># backward compatibility</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insort_left</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="string">"""Insert item x in list a, and keep it sorted assuming a is sorted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If x is already in a, insert it to the left of the leftmost x.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> a[mid] &lt; x: lo = mid+<span class="number">1</span> <span class="comment"># Limit the low end</span></span><br><span class="line">        <span class="keyword">else</span>: hi = mid</span><br><span class="line">    a.insert(lo, x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bisect_left</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="string">"""Return the index where to insert item x in list a, assuming a is sorted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The return value i is such that all e in a[:i] have e &lt; x, and all e in</span></span><br><span class="line"><span class="string">    a[i:] have e &gt;= x.  So if x already appears in the list, a.insert(x) will</span></span><br><span class="line"><span class="string">    insert just before the leftmost x already there.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> a[mid] &lt; x: lo = mid+<span class="number">1</span> <span class="comment"># Limit the low end</span></span><br><span class="line">        <span class="keyword">else</span>: hi = mid</span><br><span class="line">    <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/zxm1306192988/article/details/80627205" target="_blank" rel="noopener">从 递归 到 动态规划</a></p>
<hr>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="双向列表"><a href="#双向列表" class="headerlink" title="双向列表"></a>双向列表</h3><p>deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="string">'append'</span>, <span class="string">'appendleft'</span>, <span class="string">'clear'</span>, <span class="string">'copy'</span>, <span class="string">'count'</span>, <span class="string">'extend'</span>, <span class="string">'extendleft'</span>,</span><br><span class="line"> <span class="string">'index'</span>, <span class="string">'insert'</span>, <span class="string">'maxlen'</span>, <span class="string">'pop'</span>, <span class="string">'popleft'</span>, <span class="string">'remove'</span>, <span class="string">'reverse'</span>, <span class="string">'rotate'</span></span><br></pre></td></tr></table></figure>
<h3 id="计数器（Python源码）"><a href="#计数器（Python源码）" class="headerlink" title="计数器（Python源码）"></a>计数器（Python源码）</h3><p>当需要对 list 中的大量数据进行计数时，可以直接使用 Counter ，而不用新建字典来计数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="string">'''Dict subclass for counting hashable items.  Sometimes called a bag</span></span><br><span class="line"><span class="string">    or multiset.  Elements are stored as dictionary keys and their counts</span></span><br><span class="line"><span class="string">    are stored as dictionary values.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; c = Counter('abcdeabcdabcaba')  # count elements from a string</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; c.most_common(3)                # three most common elements</span></span><br><span class="line"><span class="string">    [('a', 5), ('b', 4), ('c', 3)]</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; sorted(c)                       # list all unique elements</span></span><br><span class="line"><span class="string">    ['a', 'b', 'c', 'd', 'e']</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; ''.join(sorted(c.elements()))   # list elements with repetitions</span></span><br><span class="line"><span class="string">    'aaaaabbbbcccdde'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; sum(c.values())                 # total of all counts</span></span><br><span class="line"><span class="string">    15</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; c['a']                          # count of letter 'a'</span></span><br><span class="line"><span class="string">    5</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; for elem in 'shazam':           # update counts from an iterable</span></span><br><span class="line"><span class="string">    ...     c[elem] += 1                # by adding 1 to each element's count</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; c['a']                          # now there are seven 'a'</span></span><br><span class="line"><span class="string">    7</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; del c['b']                      # remove all 'b'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; c['b']                          # now there are zero 'b'</span></span><br><span class="line"><span class="string">    0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; d = Counter('simsalabim')       # make another counter</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; c.update(d)                     # add in the second counter</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; c['a']                          # now there are nine 'a'</span></span><br><span class="line"><span class="string">    9</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; c.clear()                       # empty the counter</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; c</span></span><br><span class="line"><span class="string">    Counter()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Note:  If a count is set to zero or reduced to zero, it will remain</span></span><br><span class="line"><span class="string">    in the counter until the entry is deleted or the counter is cleared:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; c = Counter('aaabbc')</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; c['b'] -= 2                     # reduce the count of 'b' by two</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; c.most_common()                 # 'b' is still in, but its count is zero</span></span><br><span class="line"><span class="string">    [('a', 3), ('c', 1), ('b', 0)]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    '''</span></span><br></pre></td></tr></table></figure>
<h3 id="链表与数组相互转换"><a href="#链表与数组相互转换" class="headerlink" title="链表与数组相互转换"></a>链表与数组相互转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linked_list_node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linked_list_to_array</span><span class="params">(head)</span>:</span></span><br><span class="line">    array = []</span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        array.append(head.val)</span><br><span class="line">        head = head.next</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">array_to_linked_list</span><span class="params">(array)</span>:</span></span><br><span class="line">    ans = Linked_list_node(<span class="number">0</span>)</span><br><span class="line">    t = ans</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> array:</span><br><span class="line">        t.next = Linked_list_node(item)</span><br><span class="line">        t = t.next</span><br><span class="line">    <span class="keyword">return</span> ans.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_linked_list</span><span class="params">(head)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        print(head.val, end=<span class="string">" "</span>)</span><br><span class="line">        head = head.next</span><br><span class="line">    print(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    array = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">    print(<span class="string">"array: "</span>, array)</span><br><span class="line"></span><br><span class="line">    head = array_to_linked_list(array)</span><br><span class="line">    print(<span class="string">"print_linked_list: "</span>)</span><br><span class="line">    print_linked_list(head)</span><br><span class="line"></span><br><span class="line">    array2 = linked_list_to_array(head)</span><br><span class="line">    print(<span class="string">"array2: "</span>, array2)</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-206-反转链表"><a href="#Leetcode-206-反转链表" class="headerlink" title="Leetcode 206:反转链表"></a>Leetcode 206:反转链表</h3><p><a href="https://blog.csdn.net/qq_17550379/article/details/80647926" target="_blank" rel="noopener">Leetcode 206:反转链表（最详细解决方案！！！）</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList_1</span><span class="params">(head)</span>:</span></span><br><span class="line">    pre = <span class="keyword">None</span></span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">while</span> cur != <span class="keyword">None</span>:</span><br><span class="line">        lat = cur.next</span><br><span class="line">        cur.next = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = lat</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList_2</span><span class="params">(head)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="comment"># 如果输入结点是空，或只有一个结点，返回即可</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        newHead = reverseList_2(head.next) <span class="comment"># 将下一个结点之后的部分逆序</span></span><br><span class="line">        head.next.next = head  <span class="comment"># 反转当前结点</span></span><br><span class="line">        head.next = <span class="keyword">None</span>       <span class="comment"># 设置当前结点的下一个结点为None</span></span><br><span class="line">    <span class="keyword">return</span> newHead</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList_3</span><span class="params">(head)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:  <span class="comment"># 如果输入结点是空，或只有一个结点，返回即可</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    temp = ListNode(<span class="number">0</span>)</span><br><span class="line">    current_p = head</span><br><span class="line">    <span class="keyword">while</span> current_p:</span><br><span class="line">        c = current_p.next</span><br><span class="line">        current_p.next = temp.next</span><br><span class="line">        temp.next = current_p</span><br><span class="line">        current_p = c</span><br><span class="line">    <span class="keyword">return</span> temp.next</span><br></pre></td></tr></table></figure>

    </div>

    
    
    
        
      
        <div id="reward-container">
  <div>本站所有文章和源码均免费开放，如您喜欢，可以请我喝杯咖啡</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.jpg" alt="袁宵 微信支付">
        <p>微信支付</p>
      </div>
        
      
      <div style="display: inline-block">
        <img src="/images/alipay.jpg" alt="袁宵 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

      
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>袁宵</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://yuanxiaosc.github.io/2019/08/29/数据结构算法题解/" title="数据结构与算法题解">https://yuanxiaosc.github.io/2019/08/29/数据结构算法题解/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>
</div>

      

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/08/27/text-generation/" rel="next" title="使用语言模型GPT2来解决文本生成任务">
                  <i class="fa fa-chevron-left"></i> 使用语言模型GPT2来解决文本生成任务
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/09/11/深度学习算法的商业应用案例/" rel="prev" title="深度学习算法的商业应用案例">
                  深度学习算法的商业应用案例 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#算法题"><span class="nav-number">1.</span> <span class="nav-text">算法题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在-m-n-的乘法表中找到第k小的数的值"><span class="nav-number">1.1.</span> <span class="nav-text">在 m*n 的乘法表中找到第k小的数的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找数组中元素的最大值与最小值"><span class="nav-number">1.2.</span> <span class="nav-text">查找数组中元素的最大值与最小值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找旋转数组中的最小元素"><span class="nav-number">1.3.</span> <span class="nav-text">查找旋转数组中的最小元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#找出数组中第k小的数"><span class="nav-number">1.4.</span> <span class="nav-text">找出数组中第k小的数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#找出数组前3大的数"><span class="nav-number">1.5.</span> <span class="nav-text">找出数组前3大的数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#找出数组前K大的数"><span class="nav-number">1.6.</span> <span class="nav-text">找出数组前K大的数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#找三个有序数组的公共元素"><span class="nav-number">1.7.</span> <span class="nav-text">找三个有序数组的公共元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#求数组中两个元素的最小距离"><span class="nav-number">1.8.</span> <span class="nav-text">求数组中两个元素的最小距离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异或法"><span class="nav-number">1.9.</span> <span class="nav-text">异或法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#求数组连续最大和"><span class="nav-number">1.10.</span> <span class="nav-text">求数组连续最大和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组旋转"><span class="nav-number">1.11.</span> <span class="nav-text">数组旋转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断区间-a-b-与-c-d-是否相交，如果相交那么相交部分的长度L是多少？"><span class="nav-number">1.12.</span> <span class="nav-text">判断区间[a, b]与[c, d]是否相交，如果相交那么相交部分的长度L是多少？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#找出数组中和为S的两个数字"><span class="nav-number">1.13.</span> <span class="nav-text">找出数组中和为S的两个数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寻找最多的覆盖点"><span class="nav-number">1.14.</span> <span class="nav-text">寻找最多的覆盖点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串匹配之KMP算法"><span class="nav-number">1.15.</span> <span class="nav-text">字符串匹配之KMP算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编辑距离算法"><span class="nav-number">1.16.</span> <span class="nav-text">编辑距离算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-583-两个字符串的删除操作"><span class="nav-number">1.17.</span> <span class="nav-text">Leetcode 583. 两个字符串的删除操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最长公共子序列"><span class="nav-number">1.18.</span> <span class="nav-text">最长公共子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-718-最长重复子数组"><span class="nav-number">1.19.</span> <span class="nav-text">Leetcode 718. 最长重复子数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最长公共连续子字符串"><span class="nav-number">1.20.</span> <span class="nav-text">最长公共连续子字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Trie树（字典树，单词查找树）"><span class="nav-number">1.21.</span> <span class="nav-text">Trie树（字典树，单词查找树）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并查集"><span class="nav-number">1.22.</span> <span class="nav-text">并查集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2048小游戏"><span class="nav-number">1.23.</span> <span class="nav-text">2048小游戏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单调栈"><span class="nav-number">1.24.</span> <span class="nav-text">单调栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迷宫"><span class="nav-number">1.25.</span> <span class="nav-text">迷宫</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#杂项"><span class="nav-number">1.26.</span> <span class="nav-text">杂项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#leetcode873-最长的斐波那契子序列的长度"><span class="nav-number">1.27.</span> <span class="nav-text">leetcode873. 最长的斐波那契子序列的长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#背包问题"><span class="nav-number">1.28.</span> <span class="nav-text">背包问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-416：分割等和子集"><span class="nav-number">1.29.</span> <span class="nav-text">Leetcode 416：分割等和子集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二分查找"><span class="nav-number">1.30.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二分插入和查询算法（Python源码）"><span class="nav-number">1.31.</span> <span class="nav-text">二分插入和查询算法（Python源码）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据结构"><span class="nav-number">2.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#双向列表"><span class="nav-number">2.1.</span> <span class="nav-text">双向列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计数器（Python源码）"><span class="nav-number">2.2.</span> <span class="nav-text">计数器（Python源码）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链表与数组相互转换"><span class="nav-number">2.3.</span> <span class="nav-text">链表与数组相互转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-206-反转链表"><span class="nav-number">2.4.</span> <span class="nav-text">Leetcode 206:反转链表</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.png"
      alt="袁宵">
  <p class="site-author-name" itemprop="name">袁宵</p>
  <div class="site-description" itemprop="description">专注于人工智能领域研究，特别是自然语言处理。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives">
        
          <span class="site-state-item-count">141</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">133</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/yuanxiaoSC" title="GitHub &rarr; https://github.com/yuanxiaoSC" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:wangzichaochaochao@gmail.com" title="E-Mail &rarr; mailto:wangzichaochaochao@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>
  <div class="cc-license motion-element" itemprop="license">
    
  
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
	  

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">袁宵</span>
</div>
  <div class="addthis_inline_share_toolbox">
    <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5d9c4b1ac4deb418" async="async"></script>
  </div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">全站共 396.6k 字</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
  
</div>












        
      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.1"></script><script src="/js/motion.js?v=7.4.1"></script>
<script src="/js/schemes/pisces.js?v=7.4.1"></script>

<script src="/js/next-boot.js?v=7.4.1"></script>



  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>








  <script src="/js/local-search.js?v=7.4.1"></script>














  

  
    
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    
  

  

  

</body>
</html>
