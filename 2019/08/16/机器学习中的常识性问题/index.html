<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.7.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-32x32.ico?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico?v=7.4.1">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="baidu-site-verification" content="eYmWT0dEmt">

<link rel="stylesheet" href="/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":true,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="机器学习中的常识性问题定义：作为一名合格的机器学习从业人员必须理解和熟练掌握的机器学习领域的问题。 最新网页版：https://yuanxiaosc.github.io/categories/机器学习中的常识性问题/ PDF自助下载，在电脑端点击最新版网页右侧打印按钮即可 GitHub下载版: https://github.com/yuanxiaosc/Google-Machine-learnin">
<meta name="keywords" content="自然语言处理,深度学习,机器学习,人工智能,论文">
<meta property="og:type" content="article">
<meta property="og:title" content="机器学习中的常识性问题">
<meta property="og:url" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/index.html">
<meta property="og:site_name" content="望江人工智库">
<meta property="og:description" content="机器学习中的常识性问题定义：作为一名合格的机器学习从业人员必须理解和熟练掌握的机器学习领域的问题。 最新网页版：https://yuanxiaosc.github.io/categories/机器学习中的常识性问题/ PDF自助下载，在电脑端点击最新版网页右侧打印按钮即可 GitHub下载版: https://github.com/yuanxiaosc/Google-Machine-learnin">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/机器学习中的常识性问题_扫码阅读.png">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-c3145b3f158aa4e34fc5c01afc7f89ac_hd.jpg">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/Bagging集成学习方法.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/AdaBoost的算法流程.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/从决策树到XGBoost算法的演变.jpeg">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/XGBoost模型策略算法.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/XGBoost推导指示图.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/模型训练、预测与评估的关系.jpg">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/rnn.svg">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/lstm_3.svg">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/gru_3.svg">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/Transformer模型结构图.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/交叉熵损失函数与均方差损失函数对比.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/两种交叉熵损失函数的比较.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/优化算法的区别与联系.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/一维梯度下降.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/多维梯度下降.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/随机梯度下降.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/小批量梯度下降.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/指数加权移动平均.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/chapter_optimization_momentum_1_1.svg">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/chapter_optimization_momentum_3_1.svg">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/动量法.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/动量法2.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/AdaGrad算法.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/RMSProp算法.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/AdaDelta算法.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/Adam算法.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/理想的基于梯度的优化算法效果.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/锯齿现象.jpg">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/线性最小二乘的基本公式.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/激活函数优劣对比.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/gelu激活函数.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/softmax求导.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/softmax运算.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/Batch_Normalization算法.jpg">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/组正则化对比批正则化.png">
<meta property="og:image" content="https://raw.githubusercontent.com/taki0112/Group_Normalization-Tensorflow/master/assests/norm.png">
<meta property="og:image" content="https://raw.githubusercontent.com/taki0112/Switchable_Normalization-Tensorflow/master/assests/teaser.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/混淆矩阵和12率公式.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/二分类评价指标表格.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/目标检测交并比例子.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/目标检测交并比例子2.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/神经语言模型和统计语言模型有啥异同点.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/神经语言模型和统计语言模型有啥异同点2.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/神经语言模型和统计语言模型有啥异同点3.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/困惑度.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/神经网络全连接与局部连接对比图.jpg">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/神经网络局部连接和特征图.jpg">
<meta property="og:image" content="https://img-blog.csdn.net/20171022172015402?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGluZ3p1aHVpdG91/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/机器学习深度学习强化学习之间的关系.png">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-a2e753542fc6384ee351cabdbe6dd523_hd.jpg">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/机器学习“判定模型”和“生成模型”有什么区别？.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/机器学习“判定模型”和“生成模型”有什么区别？_1.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/机器学习“判定模型”和“生成模型”有什么区别？_2.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/概率与logit的关系.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/Logit模型和Logistic模型的区别与联系.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/Logistic回归中的Logit函数和sigmoid函数.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/逻辑回归与线性回归的区别与联系.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/TF-IDF算法步骤.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/TF-IDF的应用——提取关键词.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/提取文本关键词的方法.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/TF-IDF关键词提取.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/TextRank关键词抽取.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/LDA主题模型例子.jpeg">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/LDA主题模型例子2.jpeg">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/simhash.jpg">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/SimHash算法例子.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/用主体模型解决推荐系统中的冷启动问题.png">
<meta property="og:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/用主体模型解决推荐系统中的冷启动问题2.png">
<meta property="og:updated_time" content="2019-11-13T09:30:54.211Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="机器学习中的常识性问题">
<meta name="twitter:description" content="机器学习中的常识性问题定义：作为一名合格的机器学习从业人员必须理解和熟练掌握的机器学习领域的问题。 最新网页版：https://yuanxiaosc.github.io/categories/机器学习中的常识性问题/ PDF自助下载，在电脑端点击最新版网页右侧打印按钮即可 GitHub下载版: https://github.com/yuanxiaosc/Google-Machine-learnin">
<meta name="twitter:image" content="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/机器学习中的常识性问题_扫码阅读.png">
  <link rel="canonical" href="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>机器学习中的常识性问题 | 望江人工智库</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?359fbde2215e8ede98cdd58478ab2c53";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">望江人工智库</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">TF-KMP</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="fa fa-search fa-fw"></i>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/yuanxiaosc" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="袁宵">
      <meta itemprop="description" content="专注于机器学习前沿论文（技术）研究和应用，欢迎邮件交流。">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="望江人工智库">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">机器学习中的常识性问题

          
        </h2>

        <div class="post-meta">
		  	  
				<i class="fa fa-thumb-tack"></i>
				<font color=7D26CD>置顶</font>
				<span class="post-meta-divider">|</span>
			  
			  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
			   

              
                
              

              <time title="创建时间：2019-08-16 08:30:15" itemprop="dateCreated datePublished" datetime="2019-08-16T08:30:15+08:00">2019-08-16</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-13 17:30:54" itemprop="dateModified" datetime="2019-11-13T17:30:54+08:00">2019-11-13</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/机器学习中的常识性问题/" itemprop="url" rel="index"><span itemprop="name">机器学习中的常识性问题</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>机器学习中的常识性问题定义：作为一名合格的机器学习从业人员必须理解和熟练掌握的机器学习领域的问题。</p><ul>
<li>最新网页版：<a href="https://yuanxiaosc.github.io/categories/机器学习中的常识性问题/">https://yuanxiaosc.github.io/categories/机器学习中的常识性问题/</a></li>
<li>PDF自助下载，在电脑端点击最新版网页右侧打印按钮即可</li>
<li>GitHub下载版: <a href="https://github.com/yuanxiaosc/Google-Machine-learning-crash-course" target="_blank" rel="noopener">https://github.com/yuanxiaosc/Google-Machine-learning-crash-course</a></li>
<li>编者：袁宵</li>
</ul><a id="more"></a>

<hr>
<p>手机扫码阅读：</p>
<p><img src="/2019/08/16/机器学习中的常识性问题/机器学习中的常识性问题_扫码阅读.png" alt=""></p>
<hr>
<h2 id="一名合格的算法工程师是怎样的"><a href="#一名合格的算法工程师是怎样的" class="headerlink" title="一名合格的算法工程师是怎样的"></a>一名合格的算法工程师是怎样的</h2><blockquote>
<p>具体内容参见王喆的<a href="https://zhuanlan.zhihu.com/p/76827460" target="_blank" rel="noopener">如何准备算法工程师面试，斩获一线互联网公司机器学习岗offer？</a></p>
</blockquote>
<p>算法工程师的能力要求是相对全面的。作为算法模型的实现者和应用者，算法工程师在机器学习知识扎实的基础上，还应该具有算法的改进和实现的能力，因此工具和业务层面的要求也稍高。具体的内容来描述一下算法工程师的四个技能点：</p>
<ol>
<li>知识：主要是指你对machine learning相关知识和理论的储备</li>
<li>工具：将你的machine learning知识应用于实际业务的工具</li>
<li>逻辑：你的举一反三的能力，解决问题的条理性，发散思维的能力，你的聪明程度</li>
<li>业务：深入理解所在行业的商业模式，从业务中发现motivation并进而改进模型算法的能力</li>
</ol>
<p><img src="https://pic1.zhimg.com/80/v2-c3145b3f158aa4e34fc5c01afc7f89ac_hd.jpg" alt=""></p>
<p>那么如何找一份算法（机器学习）工程师的工作呢？请看<a href="https://github.com/yuanxiaosc/Find-a-Machine-Learning-Job" target="_blank" rel="noopener">找一份机器学习工作</a></p>
<h3 id="真算法工程师与调包侠的区别与联系？"><a href="#真算法工程师与调包侠的区别与联系？" class="headerlink" title="真算法工程师与调包侠的区别与联系？"></a>真算法工程师与调包侠的区别与联系？</h3><blockquote>
<p>参见 <a href="https://www.zhihu.com/question/327494084/answer/706317056" target="_blank" rel="noopener">现在的计算机专业（比如机器学习）已经沦为调包专业了吗？</a></p>
</blockquote>
<p>区别：“轮子造了就是用来造车的。但是车好不好, 还是要看造车的人懂不懂轮子。”也就是说真算法工程师造出来的产物优于只会调包的人。<br>联系：进阶路线，普通的调包侠 -&gt; 熟练的调包侠 -&gt; 修包侠 -&gt; 造轮子 -&gt; 真算法工程师</p>
<p>进一步引用霍华德的回答：</p>
<p>虚假的AI有以下特点：</p>
<ol>
<li>从不自己收集、处理、清洗、标注数据，而是找一个现有的数据集，疯狂 过拟合数据集。</li>
<li>科研idea主要来自于各种模块的花式排列组合，包含但不限于：各种CNN，各种RNN，各种attention，各种transformer，各种dropout，各种batchNorm，各种激活函数，各种loss function</li>
<li>而不是从实际问题和自然语言的现有挑战出发来思考idea</li>
<li>总是指望靠一个算法、一个模型可以解决所有问题</li>
</ol>
<p>想做好真实AI，必须：</p>
<ol>
<li>不断反馈，分析，改进。据说谷歌的搜索质量负责人Amit Singhal博士每天要看20个以上的不好搜索结果，然后持续不断的迭代改进。</li>
<li>面对真实环境中获取数据难，数据标注成本高，数据脏难清洗等问题</li>
<li>从实际问题和自然语言的现有挑战出发，设计针对问题最适合合理有效的模型</li>
<li>从不指望一个算法和问题可以解决所有问题，所有遇到的问题会做出合理的分析和拆解，针对各个难点设计最优解决算法，各个击破。</li>
</ol>
<hr>
<h2 id="解决机器学习问题的工作流程"><a href="#解决机器学习问题的工作流程" class="headerlink" title="解决机器学习问题的工作流程"></a>解决机器学习问题的工作流程</h2><h3 id="以文本分类为例说明解决机器学习问题的工作流程"><a href="#以文本分类为例说明解决机器学习问题的工作流程" class="headerlink" title="以文本分类为例说明解决机器学习问题的工作流程"></a>以文本分类为例说明解决机器学习问题的工作流程</h3><blockquote>
<p>具体内容参见 <a href="https://yuanxiaosc.github.io/2019/06/11/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB_%E8%B0%B7%E6%AD%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/">文本分类_谷歌机器学习指南</a></p>
</blockquote>
<p>以下是用于解决机器学习问题的工作流程的高度概述：</p>
<ul>
<li>Step 1: Gather Data</li>
<li>Step 2: Explore Your Data</li>
<li>Step 2.5: Choose a Model*</li>
<li>Step 3: Prepare Your Data</li>
<li>Step 4: Build, Train, and Evaluate Your Model</li>
<li>Step 5: Tune Hyperparameters</li>
<li>Step 6: Deploy Your Model</li>
</ul>
<hr>
<h2 id="机器学习中的集成方法"><a href="#机器学习中的集成方法" class="headerlink" title="机器学习中的集成方法"></a>机器学习中的集成方法</h2><blockquote>
<p>推荐阅读<a href="https://www.cnblogs.com/alan-blog-TsingHua/p/10903018.html" target="_blank" rel="noopener">常用的模型集成方法介绍：bagging、boosting 、stacking</a>。</p>
</blockquote>
<p>TODO: 补充目前经典的集成学习方法</p>
<p>集成学习就是组合这里的多个弱监督模型以期得到一个更好更全面的强监督模型，集成学习潜在的思想是即便某一个弱分类器得到了错误的预测，其他的弱分类器也可以将错误纠正回来。集成方法是将几种机器学习技术组合成一个预测模型的元算法，以达到减小方差（bagging）、偏差（boosting）或改进预测（stacking）的效果。</p>
<p>集成学习在各个规模的数据集上都有很好的策略。</p>
<ul>
<li>数据集大：划分成多个小数据集，学习多个模型进行组合。</li>
<li>数据集小：利用Bootstrap方法进行抽样，得到多个数据集，分别训练多个模型再进行组合。</li>
</ul>
<p>机器学习中的著名的集成方法：Bagging，Boosting以及Stacking。</p>
<h3 id="Bagging（bootstrap-aggregating，装袋）"><a href="#Bagging（bootstrap-aggregating，装袋）" class="headerlink" title="Bagging（bootstrap aggregating，装袋）"></a>Bagging（bootstrap aggregating，装袋）</h3><p>Bagging即套袋法，先说一下bootstrap，bootstrap也称为自助法，它是一种有放回的抽样方法，目的为了得到统计量的分布以及置信区间，其算法过程如下：</p>
<ol>
<li>从原始样本集中抽取训练集。每轮从原始样本集中使用Bootstraping的方法抽取n个训练样本。共进行k轮抽取，得到k个训练集。（k个训练集之间是相互独立的）</li>
<li>每次使用一个训练集得到一个模型，k个训练集共得到k个模型。（注：这里并没有具体的分类算法或回归方法，我们可以根据具体问题采用不同的分类或回归方法，如决策树、感知器等）</li>
<li>对分类问题：将上步得到的k个模型采用投票的方式得到分类结果；对回归问题，计算上述模型的均值作为最后的结果。（所有模型的重要性相同）<br><img src="/2019/08/16/机器学习中的常识性问题/Bagging集成学习方法.png" alt=""></li>
</ol>
<h3 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h3><p><a href="https://www.cnblogs.com/zongfa/p/9304353.html" target="_blank" rel="noopener">机器学习—集成学习（Ensemble Learning）</a><br>其主要思想是将弱分类器组装成一个强分类器。通过提高那些在前一轮被弱分类器分错样例的权值，减小前一轮分对样例的权值，来使得分类器对误分的数据有较好的效果。通过加法模型将弱分类器进行线性组合，比如：</p>
<ol>
<li>AdaBoost（Adaptive boosting）算法：刚开始训练时对每一个训练例赋相等的权重，然后用该算法对训练集训练t轮，每次训练后，对训练失败的训练例赋以较大的权重，也就是让学习算法在每次学习以后更注意学错的样本，从而得到多个预测函数。通过拟合残差的方式逐步减小残差，将每一步生成的模型叠加得到最终模型。</li>
<li>GBDT（Gradient Boost Decision Tree)，每一次的计算是为了减少上一次的残差，GBDT在残差减少（负梯度）的方向上建立一个新的模型。</li>
</ol>
<p><strong>AdaBoost</strong><br><img src="/2019/08/16/机器学习中的常识性问题/AdaBoost的算法流程.png" alt=""><br><a href="https://www.cnblogs.com/ScorpioLu/p/8295990.html" target="_blank" rel="noopener">AdaBoost原理详解</a></p>
<h3 id="从基于树的算法的演变过程看集成学习"><a href="#从基于树的算法的演变过程看集成学习" class="headerlink" title="从基于树的算法的演变过程看集成学习"></a>从基于树的算法的演变过程看集成学习</h3><p><img src="/2019/08/16/机器学习中的常识性问题/从决策树到XGBoost算法的演变.jpeg" alt=""></p>
<p>上述图片的直观解释：<br>假设你是面试官，要面试几名资历非常优秀的求职者。基于树的算法演变过程的每一步都可以类比为不同版本的面试场景。</p>
<ol>
<li>决策树：每一名面试官都有一套自己的面试标准，比如教育水平、工作经验以及面试表现等。决策树类似于面试官根据他（她）自己的标准面试求职者。</li>
<li>袋装法（Bagging）：现在面试官不只有一个人，而是一整个面试小组，小组中的每位面试官都有投票权。Bagging（Boostrap Aggregating）就是通过民主投票过程，综合所有面试官的投票，然后做出最终决定。</li>
<li>随机森林（Random Forest）：这是基于 Bagging 的算法，但与 Bagging 有明显区别——它随机选择特征子集。也就是，每位面试官只会随机选择一些侧面来对求职者进行面试（比如测试编程技能的技术面或者是评估非技术技能的行为面试）。</li>
<li>Boosting：这是一种替代方法，每位面试官根据前一位面试官的反馈来调整评估标准。通过部署更动态的评估流程来「提升」面试效率。</li>
<li>梯度提升（Gradient Boosting）：这是 Boosting 的特例，这种算法通过梯度下降算法来最小化误差。用面试类比的话，就是战略咨询公司用案例面试来剔除那些不符合要求的求职者；</li>
<li>XGBoost：将 XGBoost 视为极限的梯度提升。这是软硬件优化技术的完美结合，它可以在最短时间内用更少的计算资源得到更好的结果。</li>
</ol>
<p><a href="https://zhuanlan.zhihu.com/p/75468124" target="_blank" rel="noopener">决策树、随机森林、bagging、boosting、Adaboost、GBDT、XGBoost总结 知乎</a></p>
<h3 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h3><blockquote>
<p>推荐阅读 <a href="https://yuanxiaosc.github.io/2019/09/30/XGBoost的工程师手册/">XGBoost的工程师手册</a></p>
</blockquote>
<p><img src="/2019/08/16/机器学习中的常识性问题/XGBoost模型策略算法.png" alt=""></p>
<p>下图来自 XGBoost超详细推导，终于有人讲明白了！</p>
<p><img src="/2019/08/16/机器学习中的常识性问题/XGBoost推导指示图.png" alt=""></p>
<hr>
<h2 id="模型训练、预测与评估的关系"><a href="#模型训练、预测与评估的关系" class="headerlink" title="模型训练、预测与评估的关系"></a>模型训练、预测与评估的关系</h2><p><img src="/2019/08/16/机器学习中的常识性问题/模型训练、预测与评估的关系.jpg" alt=""></p>
<hr>
<h2 id="深度学习中的基础模型结构"><a href="#深度学习中的基础模型结构" class="headerlink" title="深度学习中的基础模型结构"></a>深度学习中的基础模型结构</h2><p>TODO：完善CV和NLP中的基础模型结构</p>
<h3 id="画出循环神经网络中的RNN-cell、GRU、LSTM的结构图，并说明图中各部分的作用"><a href="#画出循环神经网络中的RNN-cell、GRU、LSTM的结构图，并说明图中各部分的作用" class="headerlink" title="画出循环神经网络中的RNN_cell、GRU、LSTM的结构图，并说明图中各部分的作用"></a>画出循环神经网络中的RNN_cell、GRU、LSTM的结构图，并说明图中各部分的作用</h3><blockquote>
<p>详细内容见 <a href="https://yuanxiaosc.github.io/2018/12/18/TensorFlow_rnn_cell_impl/">TensorFlow_rnn_cell_impl源码阅读</a></p>
</blockquote>
<p>基本常用的RNN单元，如LSTM（长短期记忆）或GRU（门控循环单元）的基本计算公式是：(output, next_state) = call(input, state)</p>
<p><strong>RNN_cell</strong><br><img src="/2019/08/16/机器学习中的常识性问题/rnn.svg" alt=""></p>
<p><strong>LSTM</strong><br><img src="/2019/08/16/机器学习中的常识性问题/lstm_3.svg" alt=""></p>
<p><strong>GRU</strong><br><img src="/2019/08/16/机器学习中的常识性问题/gru_3.svg" alt=""></p>
<h3 id="画出Transformer的模型结构图，并说明图中各部分的作用"><a href="#画出Transformer的模型结构图，并说明图中各部分的作用" class="headerlink" title="画出Transformer的模型结构图，并说明图中各部分的作用"></a>画出Transformer的模型结构图，并说明图中各部分的作用</h3><blockquote>
<p>阅读 <a href="https://yuanxiaosc.github.io/2018/11/06/Attention_is_All_You_Need/">Attention is All You Need</a> 解析并结合 <a href="https://github.com/yuanxiaosc/Transformer_implementation_and_application" target="_blank" rel="noopener">Transformer 代码实现</a></p>
</blockquote>
<p><img src="/2019/08/16/机器学习中的常识性问题/Transformer模型结构图.png" alt=""></p>
<h3 id="模型结构相关的计算题"><a href="#模型结构相关的计算题" class="headerlink" title="模型结构相关的计算题"></a>模型结构相关的计算题</h3><p>推荐阅读 <a href="https://yuanxiaosc.github.io/2019/08/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E8%AE%A1%E7%AE%97%E9%A2%98/">深度学习中的计算题</a></p>
<hr>
<h2 id="机器学习中的损失函数"><a href="#机器学习中的损失函数" class="headerlink" title="机器学习中的损失函数"></a>机器学习中的损失函数</h2><p><a href="https://blog.csdn.net/zhangjunp3/article/details/80467350" target="_blank" rel="noopener">常用损失函数小结</a></p>
<p>通常机器学习每一个算法中都会有一个目标函数，算法的求解过程是通过对这个目标函数优化的过程。在分类或者回归问题中，通常使用损失函数（代价函数）作为其目标函数。损失函数用来评价模型的预测值和真实值不一样的程度，在测试集上损失函数值越小，通常模型的性能越好。不同的算法使用的损失函数不一样。损失函数分为经验风险损失函数和结构风险损失函数。经验风险损失函数指预测结果和实际结果的差别，结构风险损失函数是指经验风险损失函数加上正则项。</p>
<h3 id="交叉熵损失函数"><a href="#交叉熵损失函数" class="headerlink" title="交叉熵损失函数"></a>交叉熵损失函数</h3><p><img src="/2019/08/16/机器学习中的常识性问题/交叉熵损失函数与均方差损失函数对比.png" alt=""></p>
<p>分开定义softmax运算和交叉熵损失函数可能会造成数值不稳定。</p>
<p><strong>sigmoid和softmax后面接的两种不同交叉熵损失函数的比较</strong><br><img src="/2019/08/16/机器学习中的常识性问题/两种交叉熵损失函数的比较.png" alt=""></p>
<h3 id="两种形式的二分类交叉熵损失函数的推导"><a href="#两种形式的二分类交叉熵损失函数的推导" class="headerlink" title="两种形式的二分类交叉熵损失函数的推导"></a>两种形式的二分类交叉熵损失函数的推导</h3><p><a href="https://blog.csdn.net/red_stone1/article/details/80735068" target="_blank" rel="noopener">简单的交叉熵损失函数，你真的懂了吗？</a></p>
<p>对于类别标签为0和1的二分类交叉熵损失函数是：</p>
<script type="math/tex; mode=display">Loss=-y log \hat y - (1-y) log (1 - \hat y)</script><p>对于类别标签为1和-1的二分类交叉熵损失函数是：</p>
<script type="math/tex; mode=display">Loss=log (1 + e^{-y \hat y})</script><h3 id="为什么结合sigmoid激活函数和交叉熵损失函数能保证数值稳定？"><a href="#为什么结合sigmoid激活函数和交叉熵损失函数能保证数值稳定？" class="headerlink" title="为什么结合sigmoid激活函数和交叉熵损失函数能保证数值稳定？"></a>为什么结合sigmoid激活函数和交叉熵损失函数能保证数值稳定？</h3><p>参考TensorFlow源码 <a href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/ops/nn_impl.py#L192-L239" target="_blank" rel="noopener">nn.sigmoid_cross_entropy_with_logits</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">For brevity, let `x = logits`, `z = labels`.  The logistic loss is</span><br><span class="line">      z * -log(sigmoid(x)) + (1 - z) * -log(1 - sigmoid(x))</span><br><span class="line">    = z * -log(1 / (1 + exp(-x))) + (1 - z) * -log(exp(-x) / (1 + exp(-x)))</span><br><span class="line">    = z * log(1 + exp(-x)) + (1 - z) * (-log(exp(-x)) + log(1 + exp(-x)))</span><br><span class="line">    = z * log(1 + exp(-x)) + (1 - z) * (x + log(1 + exp(-x))</span><br><span class="line">    = (1 - z) * x + log(1 + exp(-x))</span><br><span class="line">    = x - x * z + log(1 + exp(-x))</span><br><span class="line">For x &lt; 0, to avoid overflow in exp(-x), we reformulate the above</span><br><span class="line">      x - x * z + log(1 + exp(-x))</span><br><span class="line">    = log(exp(x)) - x * z + log(1 + exp(-x))</span><br><span class="line">    = - x * z + log(1 + exp(x))</span><br><span class="line">Hence, to ensure stability and avoid overflow, the implementation uses this</span><br><span class="line">equivalent formulation</span><br><span class="line">    max(x, 0) - x * z + log(1 + exp(-abs(x)))</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="机器学习中的优化算法"><a href="#机器学习中的优化算法" class="headerlink" title="机器学习中的优化算法"></a>机器学习中的优化算法</h2><p>在训练模型时，我们会使用优化算法不断迭代模型参数以降低模型损失函数的值。当迭代终止时，模型的训练随之终止，此时的模型参数就是模型通过训练所学习到的参数。</p>
<p>优化算法对于深度学习十分重要。一方面，训练一个复杂的深度学习模型可能需要数小时、数日，甚至数周时间，而优化算法的表现直接影响模型的训练效率；另一方面，理解各种优化算法的原理以及其中超参数的意义将有助于我们更有针对性地调参，从而使深度学习模型表现更好。</p>
<p><strong>优化与深度学习的关系</strong><br>由于优化算法的目标函数通常是一个基于训练数据集的损失函数，优化的目标在于降低训练误差。 而深度学习的目标在于降低泛化误差。为了降低泛化误差，除了使用优化算法降低训练误差以外，还需要注意应对过拟合。本章中，我们只关注优化算法在最小化目标函数上的表现，而不关注模型的泛化误差。</p>
<h3 id="机器学习中的优化问题"><a href="#机器学习中的优化问题" class="headerlink" title="机器学习中的优化问题"></a>机器学习中的优化问题</h3><p><a href="https://baike.baidu.com/item/泰勒公式/7681487" target="_blank" rel="noopener">泰勒公式</a></p>
<h3 id="经典优化算法"><a href="#经典优化算法" class="headerlink" title="经典优化算法"></a>经典优化算法</h3><h3 id="SGD、AdaGrad、RMSProp、AdaDelta和Adam基于梯度的优化算法关系"><a href="#SGD、AdaGrad、RMSProp、AdaDelta和Adam基于梯度的优化算法关系" class="headerlink" title="SGD、AdaGrad、RMSProp、AdaDelta和Adam基于梯度的优化算法关系"></a>SGD、AdaGrad、RMSProp、AdaDelta和Adam基于梯度的优化算法关系</h3><p><img src="/2019/08/16/机器学习中的常识性问题/优化算法的区别与联系.png" alt=""></p>
<h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p><img src="/2019/08/16/机器学习中的常识性问题/一维梯度下降.png" alt=""><br><img src="/2019/08/16/机器学习中的常识性问题/多维梯度下降.png" alt=""><br><img src="/2019/08/16/机器学习中的常识性问题/随机梯度下降.png" alt=""><br><img src="/2019/08/16/机器学习中的常识性问题/小批量梯度下降.png" alt=""></p>
<h3 id="数加权移动平均与动量法"><a href="#数加权移动平均与动量法" class="headerlink" title="数加权移动平均与动量法"></a>数加权移动平均与动量法</h3><p><img src="/2019/08/16/机器学习中的常识性问题/指数加权移动平均.png" alt=""></p>
<p>目标函数有关自变量的梯度代表了目标函数在自变量当前位置下降最快的方向。因此，梯度下降也叫作最陡下降（steepest descent）。在每次迭代中，梯度下降根据自变量当前位置，沿着当前位置的梯度更新自变量。然而，如果自变量的迭代方向仅仅取决于自变量当前位置，这可能会带来一些问题。</p>
<p><img src="/2019/08/16/机器学习中的常识性问题/chapter_optimization_momentum_1_1.svg" alt=""></p>
<p>同一位置上，目标函数在竖直方向（ x2 轴方向）比在水平方向（ x1 轴方向）的斜率的绝对值更大。因此，给定学习率，梯度下降迭代自变量时会使自变量在竖直方向比在水平方向移动幅度更大。那么，我们需要一个较小的学习率从而避免自变量在竖直方向上越过目标函数最优解。然而，这会造成自变量在水平方向上朝最优解移动变慢。</p>
<p>下面我们试着将学习率调得稍大一点，此时自变量在竖直方向不断越过最优解并逐渐发散。</p>
<p><img src="/2019/08/16/机器学习中的常识性问题/chapter_optimization_momentum_3_1.svg" alt=""></p>
<p><img src="/2019/08/16/机器学习中的常识性问题/动量法.png" alt=""><br><img src="/2019/08/16/机器学习中的常识性问题/动量法2.png" alt=""></p>
<p>动量法使用了指数加权移动平均的思想。它将过去时间步的梯度做了加权平均，且权重按时间步指数衰减。动量法使得相邻时间步的自变量更新在方向上更加一致。</p>
<h3 id="AdaGrad算法"><a href="#AdaGrad算法" class="headerlink" title="AdaGrad算法"></a>AdaGrad算法</h3><p>AdaGrad算法，它根据自变量在每个维度的梯度值的大小来调整各个维度上的学习率，从而避免统一的学习率难以适应所有维度的问题。</p>
<p><img src="/2019/08/16/机器学习中的常识性问题/AdaGrad算法.png" alt=""></p>
<h3 id="RMSProp算法"><a href="#RMSProp算法" class="headerlink" title="RMSProp算法"></a>RMSProp算法</h3><p>我们在“AdaGrad算法”一节中提到，因为调整学习率时分母上的变量 $s_t$ 一直在累加按元素平方的小批量随机梯度，所以目标函数自变量每个元素的学习率在迭代过程中一直在降低（或不变）。因此，当学习率在迭代早期降得较快且当前解依然不佳时，AdaGrad算法在迭代后期由于学习率过小，可能较难找到一个有用的解。为了解决这一问题，RMSProp算法对AdaGrad算法做了一点小小的修改。</p>
<p><img src="/2019/08/16/机器学习中的常识性问题/RMSProp算法.png" alt=""></p>
<h3 id="AdaDelta算法"><a href="#AdaDelta算法" class="headerlink" title="AdaDelta算法"></a>AdaDelta算法</h3><p>除了RMSProp算法以外，另一个常用优化算法AdaDelta算法也针对AdaGrad算法在迭代后期可能较难找到有用解的问题做了改进。AdaDelta算法没有学习率超参数，它通过使用有关自变量更新量平方的指数加权移动平均的项来替代RMSProp算法中的学习率。</p>
<p><img src="/2019/08/16/机器学习中的常识性问题/AdaDelta算法.png" alt=""></p>
<h3 id="Adam算法"><a href="#Adam算法" class="headerlink" title="Adam算法"></a>Adam算法</h3><p>Adam算法在RMSProp算法基础上对小批量随机梯度也做了指数加权移动平均。</p>
<p><img src="/2019/08/16/机器学习中的常识性问题/Adam算法.png" alt=""></p>
<h3 id="在小批量梯度下降算法使用中的注意事项"><a href="#在小批量梯度下降算法使用中的注意事项" class="headerlink" title="在小批量梯度下降算法使用中的注意事项"></a>在小批量梯度下降算法使用中的注意事项</h3><p>以下仅为经验结论，一切以具体实验结果为准：</p>
<ol>
<li>批量大小一般选取2的正数次幂，例如32、64、128、256等。这样能充分利用矩阵运算操作。</li>
<li>挑选的批量数据要具有随机性，避免数据的特定顺序给算法收敛带来不良影响。</li>
<li>选取较优的学习速度，为了加快收敛速度，同时提高求解精度，通常会采用衰减学习速率的方案：一开始算法采用较大的学习速率，当误差曲线进入平台期后，减小学习速率做更精细的调整。</li>
</ol>
<h3 id="锯齿现象（zig-zagging）"><a href="#锯齿现象（zig-zagging）" class="headerlink" title="锯齿现象（zig-zagging）"></a>锯齿现象（zig-zagging）</h3><p>梯度下降方法得到的是局部最优解，如果目标函数是一个凸优化问题，那么局部最优解就是全局最优解，理想的优化效果如下图，值得注意一点的是，每一次迭代的移动方向都与出发点的等高线垂直：</p>
<p><img src="/2019/08/16/机器学习中的常识性问题/理想的基于梯度的优化算法效果.png" alt=""></p>
<p>需要指出的是，在某些情况下，最速下降法存在锯齿现象（ zig-zagging）将会导致收敛速度变慢（可以使用特征归一化来解决锯齿现象）:</p>
<p><img src="/2019/08/16/机器学习中的常识性问题/锯齿现象.jpg" alt=""><br>粗略来讲，在二次函数中，椭球面的形状受 hesse 矩阵的条件数影响，长轴与短轴对应矩阵的最小特征值和最大特征值的方向，其大小与特征值的平方根成反比，最大特征值与最小特征值相差越大，椭球面越扁，那么优化路径需要走很大的弯路，计算效率很低。</p>
<h3 id="牛顿法与拟牛顿法"><a href="#牛顿法与拟牛顿法" class="headerlink" title="牛顿法与拟牛顿法"></a>牛顿法与拟牛顿法</h3><p><a href="https://www.cnblogs.com/ljy2013/p/5129294.html" target="_blank" rel="noopener">无约束优化算法——牛顿法与拟牛顿法（DFP，BFGS，LBFGS）</a></p>
<h3 id="牛顿法、梯度下降与最速下降法对比"><a href="#牛顿法、梯度下降与最速下降法对比" class="headerlink" title="牛顿法、梯度下降与最速下降法对比"></a>牛顿法、梯度下降与最速下降法对比</h3><ul>
<li>牛顿法提供了对函数的二阶近似，并在每一步都对函数进行优化。其最大的问题在于，在优化过程中需要进行矩阵转换，对于多变量情形花销过高（尤其是向量的特征较多的时候）。</li>
<li>梯度下降是最常用的优化算法。由于该算法在每步只对导数进行计算，其花销较低，速度更快。但是在使用该算法时，需要对步长的超参数进行多次的猜测和尝试。</li>
<li>最速下降法在每步都对函数的梯度向量寻找最优步长。它的问题在于，在每次迭代中需要对相关的函数进行优化，这会带来很多花销。</li>
</ul>
<h3 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h3><p><a href="https://baike.baidu.com/item/最小二乘法/2522346" target="_blank" rel="noopener">最小二乘法 百度百科</a></p>
<p>最小二乘法（又称最小平方法）是一种数学优化技术。它通过最小化误差的平方和寻找数据的最佳函数匹配。利用最小二乘法可以简便地求得未知的数据，并使得这些求得的数据与实际数据之间误差的平方和为最小。最小二乘法还可用于曲线拟合。其他一些优化问题也可通过最小化能量或最大化熵用最小二乘法来表达。</p>
<p><img src="/2019/08/16/机器学习中的常识性问题/线性最小二乘的基本公式.png" alt=""></p>
<hr>
<h2 id="机器学习中的激活函数"><a href="#机器学习中的激活函数" class="headerlink" title="机器学习中的激活函数"></a>机器学习中的激活函数</h2><p><strong>为什么引入非线性激励函数？</strong><br>如果不用激励函数（其实相当于激励函数是f(x) = x），在这种情况下你每一层输出都是上层输入的线性函数，很容易验证，无论你神经网络有多少层，输出都是输入的线性组合，与没有隐藏层效果相当，这种情况就是最原始的感知机（Perceptron）了。正因为上面的原因，我们决定引入非线性函数作为激励函数，这样深层神经网络就有意义了（不再是输入的线性组合，可以逼近任意函数）。最早的想法是sigmoid函数或者tanh函数，输出有界，很容易充当下一层输入（以及一些人的生物解释）。</p>
<p><strong>为什么引入Relu呢？</strong><br>第一，采用sigmoid等函数，算激活函数时（指数运算），计算量大，反向传播求误差梯度时，求导涉及除法，计算量相对大，而采用Relu激活函数，整个过程的计算量节省很多。<br>第二，对于深层网络，sigmoid函数反向传播时，很容易就会出现梯度消失的情况（在sigmoid接近饱和区时，变换太缓慢，导数趋于0，这种情况会造成信息丢失，从而无法完成深层网络的训练。<br>第三，Relu会使一部分神经元的输出为0，这样就造成了网络的稀疏性，并且减少了参数的相互依存关系，缓解了过拟合问题的发生（以及一些人的生物解释）。当然现在也有一些对relu的改进，比如prelu，random relu等。</p>
<p><strong>激活函数优劣对比</strong><br><img src="/2019/08/16/机器学习中的常识性问题/激活函数优劣对比.png" alt=""></p>
<h3 id="Sigmoid"><a href="#Sigmoid" class="headerlink" title="Sigmoid"></a>Sigmoid</h3><p>$sigmoid(x)=\frac{1}{1+e^{-x}}$<br>$f’(z)=f(x)(1-f(x))$</p>
<h3 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h3><p>$tanh(x)=\frac{e^x-e^{-x}}{e^x+e^{-x}}$<br>$f’(x)=1 - f^(x)$</p>
<p><a href="https://www.zhihu.com/question/61265076/answer/186347780" target="_blank" rel="noopener">RNN中为什么要采用tanh而不是ReLu作为激活函数？</a></p>
<h3 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h3><p>线性整流函数（Rectified Linear Unit, ReLU），又称修正线性单元，是一种人工神经网络中常用的激活函数，通常指代以斜坡函数及其变种为代表的非线性函数。</p>
<p>$Relu=max(0, x)$</p>
<p><strong>Dead Relu</strong><br>ReLU神经元对于所有的data point input，输出都是0，这是我们就说这个ReLU死掉了。<br><a href="https://zhuanlan.zhihu.com/p/67054518" target="_blank" rel="noopener">由dead relu引发的思考——正则化算法漫谈</a></p>
<h3 id="Leaky-ReLU"><a href="#Leaky-ReLU" class="headerlink" title="Leaky ReLU"></a>Leaky ReLU</h3><p>$f(x)=max(\alpha x, x)$</p>
<h3 id="ELU"><a href="#ELU" class="headerlink" title="ELU"></a>ELU</h3><p>$f(x)= \begin{cases}x,&amp; \text{if } x &gt; 0\\<br> \alpha(e^x - 1), &amp; \text{otherwise}<br>\end{cases}$</p>
<h3 id="gelu"><a href="#gelu" class="headerlink" title="gelu"></a>gelu</h3><blockquote>
<p>参见<a href="https://blog.csdn.net/sinat_36618660/article/details/100088097" target="_blank" rel="noopener">深度学习中的gelu激活函数详解</a></p>
</blockquote>
<p>gelu（gaussian error linear units）就是我们常说的高斯误差线性单元，它是一种高性能的神经网络激活函数，因为gelu的非线性变化是一种符合预期的随机正则变换方式。原始论文：<a href="https://arxiv.org/abs/1606.08415" target="_blank" rel="noopener">https://arxiv.org/abs/1606.08415</a></p>
<p><img src="/2019/08/16/机器学习中的常识性问题/gelu激活函数.png" alt=""></p>
<h3 id="Softmax"><a href="#Softmax" class="headerlink" title="Softmax"></a>Softmax</h3><p>$a_i=\frac{e^{z_i}}{\sum_k e^{z_k}}$</p>
<p><img src="/2019/08/16/机器学习中的常识性问题/softmax求导.png" alt=""></p>
<p><strong>Softmax运算</strong></p>
<p><img src="/2019/08/16/机器学习中的常识性问题/softmax运算.png" alt=""></p>
<hr>
<h2 id="机器学习中的正则化方法"><a href="#机器学习中的正则化方法" class="headerlink" title="机器学习中的正则化方法"></a>机器学习中的正则化方法</h2><p><a href="https://www.cnblogs.com/maybe2030/p/9231231.html" target="_blank" rel="noopener">正则化 Poll的笔记</a></p>
<h3 id="L1-Normalization"><a href="#L1-Normalization" class="headerlink" title="L1 Normalization"></a>L1 Normalization</h3><h3 id="L1-正则化使得模型参数具有稀疏性的原理是什么？"><a href="#L1-正则化使得模型参数具有稀疏性的原理是什么？" class="headerlink" title="L1 正则化使得模型参数具有稀疏性的原理是什么？"></a>L1 正则化使得模型参数具有稀疏性的原理是什么？</h3><p>回答角度如下：</p>
<ol>
<li>解空间形状</li>
<li>函数叠加</li>
<li>贝叶斯先验</li>
</ol>
<h3 id="L2-Normalization"><a href="#L2-Normalization" class="headerlink" title="L2 Normalization"></a>L2 Normalization</h3><h3 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h3><p><a href="https://www.zhihu.com/question/38102762" target="_blank" rel="noopener">深度学习中 Batch Normalization为什么效果好？</a><br>batch normalization有效地加快了模型的收敛速度，在一定程度缓解了深层网络中“梯度弥散”的问题，从而使得训练深层网络模型更加容易和稳定。batch normalization的算法过程如下：</p>
<p><img src="/2019/08/16/机器学习中的常识性问题/Batch_Normalization算法.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.求当前batch的数据的均值u和方差sigma</span><br><span class="line">2.将当前的所有数据减去均值u</span><br><span class="line">3.将当前的所有数据除以方差的平方根sqrt(sigma)</span><br><span class="line">4.将经过前三步之后得到的数据乘以gamma，再加上betta，这里的gamma和betta是可学习的参数</span><br></pre></td></tr></table></figure>
<p>前三步很好理解，将数据减去均值，再除以方差，可以将数据归一到正态分布。那第四步该如何理解呢，又有什么作用呢？从公式上看，第四步相当于把已处于正态分布的数据乘以了一个尺度因子gamma，再加上了一个平移因子betta，这不是又逆向回原来的分布了吗？当然不是，第四步的gamma和betta是可学习的参数，网络会通过权重更新自己去调节这两个参数，使得它拟合现有的模型参数。如果取消了第四步，那相当于经过了bn层之后的数据都变成了正态分布，这样不利于网络去表达数据的差异性，会降低网络的性能，加上了第四步之后，网络会根据模型的特点自动地去调整数据的分布，更有利于模型的表达能力。</p>
<h3 id="Group-Normalization"><a href="#Group-Normalization" class="headerlink" title="Group Normalization"></a>Group Normalization</h3><p>Batch Normalization的效果虽好，但是它也有一些缺陷，当batch_size较小的时候，bn算法的效果就会下降，这是因为在较小的batch_size中，bn层难以学习到正确的样本分布，导致gamma和betta参数学习的不好。为了解决这一问题，Facebook AI Research提出了Group Normalization。</p>
<p><img src="/2019/08/16/机器学习中的常识性问题/组正则化对比批正则化.png" alt=""></p>
<p>从上图可以看出，随着batch_size的减小，batch norm的error率逐渐上升，而group norm的error率几乎不变。在一些目标检测方面的模型中，例如faster-rcnn或mask-rcnn，当你只拥有一个GPU时，要求的batch_size通常为1或2张图片，这种情况下batch norm的效果就会大打折扣。那么group norm是如何改进这一点的呢？下面来看下group norm的算法流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.将当前层的数据在通道的维度上划分为多个group</span><br><span class="line">2.求出每个group中的数据的均值和方差</span><br><span class="line">3.将每个group中的数据减去它们相应的均值再除以方差的平方根</span><br><span class="line">4.将经过前三步之后得到的数据乘以gamma，再加上betta</span><br></pre></td></tr></table></figure>
<p>可以看出，group normalization和batch normalization的算法过程极为相似，仅仅通过划分group这样的简单操作就改善了batch norm所面临的问题，在实际应用中取得了非常好的效果。</p>
<h3 id="对比BatchNorm、LayerNorm、InstanceNorm、GroupNorm"><a href="#对比BatchNorm、LayerNorm、InstanceNorm、GroupNorm" class="headerlink" title="对比BatchNorm、LayerNorm、InstanceNorm、GroupNorm"></a>对比BatchNorm、LayerNorm、InstanceNorm、GroupNorm</h3><p><img src="https://raw.githubusercontent.com/taki0112/Group_Normalization-Tensorflow/master/assests/norm.png" alt=""><br><img src="https://raw.githubusercontent.com/taki0112/Switchable_Normalization-Tensorflow/master/assests/teaser.png" alt=""></p>
<p>上图的N就是 batch，形状为 [batch, height, width, channel] 的特征图经过正则化时的计算轴和计算后的均值、方差的张量形状：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>BatchNorm</th>
<th>LayerNorm</th>
<th>InstanceNorm</th>
<th>GroupNorm</th>
</tr>
</thead>
<tbody>
<tr>
<td>batch, height, width</td>
<td>height, width, channel</td>
<td>height, width</td>
<td>height, width, channel // Group</td>
</tr>
<tr>
<td>[1, 1, 1, channel]</td>
<td>[batch, 1, 1, 1]</td>
<td>[batch, 1, 1, channel]</td>
<td>[batch, 1, 1, Group, 1]</td>
</tr>
</tbody>
</table>
</div>
<p>注：GroupNorm时首先会将输入[batch, height, width, channel]根据设定的组数Group分组得到 [batch, height, width, Group, channel // Group]，然后在对[1, 2, 4]轴上的数据计算均值和方差。</p>
<p><a href="https://blog.csdn.net/xu_fu_yong/article/details/93721585" target="_blank" rel="noopener">BatchNormalization、LayerNormalization、InstanceNorm、GroupNorm的通俗理解</a><br><a href="https://blog.csdn.net/liuxiao214/article/details/81037416" target="_blank" rel="noopener">BatchNormalization、LayerNormalization、InstanceNorm、GroupNorm、SwitchableNorm的相关论文、计算公式和代码总结</a></p>
<ul>
<li>BatchNorm：batch方向做归一化，算NHW的均值，对小batchsize效果不好；BN主要缺点是对batchsize的大小比较敏感，由于每次计算均值和方差是在一个batch上，所以如果batchsize太小，则计算的均值、方差不足以代表整个数据分布</li>
<li>LayerNorm：channel方向做归一化，算CHW的均值，主要对RNN作用明显；</li>
<li>InstanceNorm：一个channel内做归一化，算H*W的均值，用在风格化迁移；因为在图像风格化中，生成结果主要依赖于某个图像实例，所以对整个batch归一化不适合图像风格化中，因而对HW做归一化。可以加速模型收敛，并且保持每个图像实例之间的独立。</li>
<li>GroupNorm：将channel方向分group，然后每个group内做归一化，算(C//G)HW的均值；这样与batchsize无关，不受其约束。</li>
<li>SwitchableNorm是将BN、LN、IN结合，赋予权重，让网络自己去学习归一化层应该使用什么方法。</li>
</ul>
<h3 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h3><hr>
<h2 id="机器学习中的模型训练技巧"><a href="#机器学习中的模型训练技巧" class="headerlink" title="机器学习中的模型训练技巧"></a>机器学习中的模型训练技巧</h2><p>TODO：丰富内容</p>
<ul>
<li><a href="http://karpathy.github.io/2019/04/25/recipe/" target="_blank" rel="noopener">A Recipe for Training Neural Networks</a></li>
<li><a href="http://lamda.nju.edu.cn/weixs/project/CNNTricks/CNNTricks.html" target="_blank" rel="noopener">Must Know Tips/Tricks in Deep Neural Networks (by Xiu-Shen Wei)</a></li>
</ul>
<hr>
<h2 id="机器学习中的评价指标"><a href="#机器学习中的评价指标" class="headerlink" title="机器学习中的评价指标"></a>机器学习中的评价指标</h2><p>TODO：增加多分类、图片相关的评价指标</p>
<h3 id="二分类评价指标"><a href="#二分类评价指标" class="headerlink" title="二分类评价指标"></a>二分类评价指标</h3><p>正例（Positives）：你所关注的识别目标就是正例。<br>负例（Negatives）：正例以外的就是负例。</p>
<p><img src="/2019/08/16/机器学习中的常识性问题/混淆矩阵和12率公式.png" alt=""><br><img src="/2019/08/16/机器学习中的常识性问题/二分类评价指标表格.png" alt=""></p>
<h3 id="机器翻译（文本生成）评价指标"><a href="#机器翻译（文本生成）评价指标" class="headerlink" title="机器翻译（文本生成）评价指标"></a>机器翻译（文本生成）评价指标</h3><p>参考 <a href="https://blog.csdn.net/joshuaxx316/article/details/58696552" target="_blank" rel="noopener">BLEU，ROUGE，METEOR，ROUGE-浅述自然语言处理机器翻译常用评价度量 CSDN</a></p>
<p>机器翻译常用评价度量：</p>
<ul>
<li>客观评价指标：BLEU、ROUGE、METEOR、CIDEr</li>
<li>主观评价指标 ：流畅度、相关性、助盲性</li>
</ul>
<p>注意这些指标不是完全独立，而是有相互的联系。比如客观评价指标BLEU采用了N-gram的匹配规则，通过它能够算出比较译文和参考译文之间n组词的相似的一个占比。一般情况1-gram可以代表原文有多少词被单独翻译出来，可以反映译文的充分性，2-gram以上可以反映译文的流畅性，它的值越高说明可读性越好。这两个指标是能够跟人工评价对应的。</p>
<p><strong>BLEU (Bilingual Evaluation Understudy) 的内容、存在的问题、以及如何在工作中最大限度地减少这些问题？</strong></p>
<ul>
<li>BLEU内容见 <a href="https://blog.csdn.net/wwj_748/article/details/79686042" target="_blank" rel="noopener">机器翻译质量评测算法-BLEU CSDN</a></li>
<li>BLEU存在问题和解决方法见 <a href="https://towardsdatascience.com/evaluating-text-output-in-nlp-bleu-at-your-own-risk-e8609665a213" target="_blank" rel="noopener">Evaluating Text Output in NLP: BLEU at your own risk</a> 或者 <a href="https://mp.weixin.qq.com/s?__biz=MzI0ODcxODk5OA==&amp;mid=2247502658&amp;idx=4&amp;sn=2eb8e20821f2626c29ea5ef2a4cf2918&amp;scene=0#wechat_redirect" target="_blank" rel="noopener">NLP输出文本评估：使用BLEU需要承担哪些风险？</a></li>
</ul>
<h3 id="目标检测的评价指标IoU"><a href="#目标检测的评价指标IoU" class="headerlink" title="目标检测的评价指标IoU"></a>目标检测的评价指标IoU</h3><p>IoU（Intersection-over-Union）交并比，顾名思义数学中交集与并集的比例。假设有两个集合A与B, IoU即等于A与B的交集除以A与B的并集，表达式如下：</p>
<script type="math/tex; mode=display">IoU = \frac {A \cap B}{A \cup B}</script><p>在目标检测中，IoU为预测框(Prediction)和真实框(Ground truth)的交并比。如下图所示，在关于小猫的目标检测中，紫线边框为预测框(Prediction)，红线边框为真实框(Ground truth)。</p>
<p><img src="/2019/08/16/机器学习中的常识性问题/目标检测交并比例子.png" alt=""></p>
<p>将预测框与真实框提取如下图，两者的交集区域为左下图斜线填充的部分，两者的并集区域为右下图蓝色填充的区域。IoU即为：左边斜线填充的面积/右边蓝色填充的总面积。</p>
<p><img src="/2019/08/16/机器学习中的常识性问题/目标检测交并比例子2.png" alt=""></p>
<p>在目标检测任务中，通常取IoU≥0.5，认为召回。如果IoU阈值设置更高，召回率将会降低，但定位框则更加精确。理想的情况，当然是预测框与真实框重叠越多越好，如果两者完全重叠，则交集与并集面积相同，此时IoU等于1。</p>
<h3 id="图像分类评价指标TopK"><a href="#图像分类评价指标TopK" class="headerlink" title="图像分类评价指标TopK"></a>图像分类评价指标TopK</h3><ul>
<li><p>Top1：对一张图片，模型给出的识别概率中（即置信度分数），分数最高的为正确目标，则认为正确。这里的目标也就是我们说的正例。</p>
</li>
<li><p>TopK: 对一张图片，模型给出的识别概率中（即置信度分数），分数排名前K位中包含有正确目标（正确的正例），则认为正确。K的取值一般可在100以内的量级，当然越小越实用。比如较常见的，K取值为5，则表示为Top5，代表置信度分数排名前5当中有一个是正确目标即可；如果K取值100，则表示为Top100，代表置信度分数排名前100当中有一个是正确目标（正确的正例）即可。可见，随着K增大，难度下降。</p>
</li>
</ul>
<hr>
<h2 id="机器学习中的模型选择"><a href="#机器学习中的模型选择" class="headerlink" title="机器学习中的模型选择"></a>机器学习中的模型选择</h2><p>两种常见的模型选择方法：正则化与交叉验证。</p>
<p>正则化的作用是选择经验风险与模型复杂度同时较小的模型。<br>当数据充足时，将数据集划分为训练集、验证集和测试集，通过验证集来选择模型。当数据不充足时，采用交叉验证的方法。</p>
<h3 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h3><ol>
<li>简单交叉验证。首先随机将已给数据部分分为两部分，一部分作为训练集，另一部分作为测试集；然后用训练集在各种条件下（例如，不同的参数个数）训练模型，从而得到不同的模型；在测试集上评价各个模型的测试误差，选出测试误差最小的模型。</li>
<li>S折交叉验证。首先随机地将已给数据且分为S个不互相交的大小相同的子集；然后利用S-1个子集的数据训练模型，利用余下的子集测试模型；将这一过程对可能的S种选择重复进行；最后选出S次测评中平均测试误差最小的模型。</li>
<li>留一交叉验证。当S=N，N为数据集大小，称为留一交叉验证。</li>
</ol>
<hr>
<h2 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h2><p>TODO: 完善内容</p>
<p><a href="https://yuanxiaosc.github.io/2018/08/26/%E4%B8%BB%E6%88%90%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%E3%80%81%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8%E5%92%8C%E5%8F%98%E5%88%86%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8%E8%A7%A3%E6%9E%90/">主成成分分析、自编码器和变分自编码器解析</a></p>
<h3 id="主成分分析（PCA）"><a href="#主成分分析（PCA）" class="headerlink" title="主成分分析（PCA）"></a>主成分分析（PCA）</h3><p>参见 <a href="https://blog.csdn.net/program_developer/article/details/80632779" target="_blank" rel="noopener">主成分分析（PCA）原理详解</a><br>PCA的概念<br>PCA(Principal Component Analysis)，即主成分分析方法，是一种使用最广泛的数据降维算法。PCA的主要思想是将n维特征映射到k维上，这k维是全新的正交特征也被称为主成分，是在原有n维特征的基础上重新构造出来的k维特征。PCA的工作就是从原始的空间中顺序地找一组相互正交的坐标轴，新的坐标轴的选择与数据本身是密切相关的。其中，第一个新坐标轴选择是原始数据中方差最大的方向，第二个新坐标轴选取是与第一个坐标轴正交的平面中使得方差最大的，第三个轴是与第1,2个轴正交的平面中方差最大的。依次类推，可以得到n个这样的坐标轴。通过这种方式获得的新的坐标轴，我们发现，大部分方差都包含在前面k个坐标轴中，后面的坐标轴所含的方差几乎为0。于是，我们可以忽略余下的坐标轴，只保留前面k个含有绝大部分方差的坐标轴。事实上，这相当于只保留包含绝大部分方差的维度特征，而忽略包含方差几乎为0的特征维度，实现对数据特征的降维处理。</p>
<p>思考：我们如何得到这些包含最大差异性的主成分方向呢？</p>
<p>答案：事实上，通过计算数据矩阵的协方差矩阵，然后得到协方差矩阵的特征值特征向量，选择特征值最大(即方差最大)的k个特征所对应的特征向量组成的矩阵。这样就可以将数据矩阵转换到新的空间当中，实现数据特征的降维。</p>
<p>由于得到协方差矩阵的特征值特征向量有两种方法：特征值分解协方差矩阵、奇异值分解协方差矩阵，所以PCA算法有两种实现方法：基于特征值分解协方差矩阵实现PCA算法、基于SVD分解协方差矩阵实现PCA算法。</p>
<h3 id="线性判别分析（LDA）"><a href="#线性判别分析（LDA）" class="headerlink" title="线性判别分析（LDA）"></a>线性判别分析（LDA）</h3><p>LDA是一种监督学习的降维技术，也就是说它的数据集的每个样本是有类别输出的。这点和PCA不同。PCA是不考虑样本类别输出的无监督降维技术。LDA的思想可以用一句话概括，就是“投影后类内方差最小，类间方差最大”。</p>
<h3 id="主成分分析（PCA）与线性判别分析（LDA）区别与联系"><a href="#主成分分析（PCA）与线性判别分析（LDA）区别与联系" class="headerlink" title="主成分分析（PCA）与线性判别分析（LDA）区别与联系"></a>主成分分析（PCA）与线性判别分析（LDA）区别与联系</h3><p><a href="https://www.cnblogs.com/mfryf/p/8884392.html" target="_blank" rel="noopener">线性判别分析LDA原理总结</a><br>LDA用于降维，和PCA有很多相同，也有很多不同的地方，因此值得好好的比较一下两者的降维异同点。</p>
<p>首先我们看看相同点：<br>1）两者均可以对数据进行降维。<br>2）两者在降维时均使用了矩阵特征分解的思想。<br>3）两者都假设数据符合高斯分布。</p>
<p>我们接着看看不同点：<br>1）LDA是有监督的降维方法，而PCA是无监督的降维方法<br>2）LDA降维最多降到类别数k-1的维数，而PCA没有这个限制。<br>3）LDA除了可以用于降维，还可以用于分类。<br>4）LDA选择分类性能最好的投影方向，而PCA选择样本点投影具有最大方差的方向。</p>
<hr>
<h2 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h2><p><a href="https://baike.baidu.com/item/语言模型/5719140" target="_blank" rel="noopener">语言模型 百度百科</a><br>语言模型是根据语言客观事实而进行的语言抽象数学建模，是一种对应关系。语言模型与语言客观事实之间的关系，如同数学上的抽象直线与具体直线之间的关系。</p>
<p>斯坦福公开课的自然语言处理 <a href="https://blog.csdn.net/a635661820/article/details/43906731" target="_blank" rel="noopener">统计语言模型详解</a></p>
<p><a href="https://baike.baidu.com/item/神经语言模型/22691890" target="_blank" rel="noopener">神经语言模型 百度百科</a><br>神经语言模型（Neural Language Model，NLM）是一类用来克服维数灾难的语言模型，它使用词的分布式表示对自然语言序列建模。不同于基于类的n-gram模型，神经语言模型在能够识别两个相似的词，并且不丧失将每个词编码为彼此不同的能力。神经语言模型共享一个词（及其上下文）和其他类似词。<br>语言模型（language model）定义了自然语言中标记序列的概率分布。根据模型的设计，标记可以是词、字符、甚至是字节。标记总是离散的实体。最早成功的语言模型基于固定长度序列的标记模型，称为n-gram。一个n-gram 是一个包含n个标记的序列。基于n-gram 的模型定义一个条件概率——给定前n−1个标记后的第n个标记的条件概率。神经语言模型是由Bengio等人在2003年提出的，共享一个词（及其上下文）和其他类似词和上下文之间的统计强度。模型为每个词学习的分布式表示，允许模型处理具有类似共同特征的词来实现这种共享。</p>
<h3 id="词向量、词嵌入与语言模型的关系？"><a href="#词向量、词嵌入与语言模型的关系？" class="headerlink" title="词向量、词嵌入与语言模型的关系？"></a>词向量、词嵌入与语言模型的关系？</h3><p>词向量通常指通过语言模型学习得到的词的分布式特征表示，也被称为词编码，可以非稀疏的表示大规模语料中复杂的上下文信息。分布式词向量可以表示为多维空间中的一个点，而具有多个词向量的单词在空间上表示为数个点的集合，也可以看作在一个椭球分布上采集的数个样本 。<br>词嵌入是自然语言处理（NLP）中语言模型与表征学习技术的统称。概念上而言，它是指把一个维数为所有词的数量的高维空间嵌入到一个维数低得多的连续向量空间中，每个单词或词组被映射为实数域上的向量。词嵌入的方法包括人工神经网络、对词语同现矩阵降维、概率模型以及单词所在上下文的显式表示等。在底层输入中，使用词嵌入来表示词组的方法极大提升了NLP中语法分析器和文本情感分析等的效果。</p>
<h3 id="神经语言模型和统计语言模型有啥异同点？"><a href="#神经语言模型和统计语言模型有啥异同点？" class="headerlink" title="神经语言模型和统计语言模型有啥异同点？"></a>神经语言模型和统计语言模型有啥异同点？</h3><p><a href="https://www.zhihu.com/question/29456588" target="_blank" rel="noopener">神经语言模型和统计语言模型有啥异同点？ 知乎</a><br><img src="/2019/08/16/机器学习中的常识性问题/神经语言模型和统计语言模型有啥异同点.png" alt=""><br><img src="/2019/08/16/机器学习中的常识性问题/神经语言模型和统计语言模型有啥异同点2.png" alt=""></p>
<p><a href="https://www.jianshu.com/p/5eb918664995" target="_blank" rel="noopener">nlp中的传统语言模型与神经语言模型 简书</a><br><img src="/2019/08/16/机器学习中的常识性问题/神经语言模型和统计语言模型有啥异同点3.png" alt=""></p>
<h3 id="语言模型的评价指标-困惑度？"><a href="#语言模型的评价指标-困惑度？" class="headerlink" title="语言模型的评价指标-困惑度？"></a>语言模型的评价指标-困惑度？</h3><p><a href="https://baike.baidu.com/item/困惑度/22742666" target="_blank" rel="noopener">困惑度 百度百科</a><br>在信息论中，perplexity(困惑度)用来度量一个概率分布或概率模型预测样本的好坏程度。它也可以用来比较两个概率分布或概率模型。（译者：应该是比较两者在预测样本上的优劣）低困惑度的概率分布模型或概率模型能更好地预测样本。</p>
<p><img src="/2019/08/16/机器学习中的常识性问题/困惑度.png" alt=""></p>
<hr>
<h2 id="LDA主题模型"><a href="#LDA主题模型" class="headerlink" title="LDA主题模型"></a>LDA主题模型</h2><ul>
<li><a href="https://cloud.tencent.com/developer/article/1058777" target="_blank" rel="noopener">通俗理解LDA主题模型</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/31470216" target="_blank" rel="noopener">一文详解LDA主题模型</a></li>
<li><a href="https://www.cnblogs.com/gasongjian/p/7631978.html" target="_blank" rel="noopener">LDA数学八卦</a></li>
<li>LDA主题模型原始论文 <a href="http://www.jmlr.org/papers/volume3/blei03a/blei03a.pdf" target="_blank" rel="noopener">Latent Dirichlet Allocation</a></li>
</ul>
<hr>
<h2 id="word2vector"><a href="#word2vector" class="headerlink" title="word2vector"></a>word2vector</h2><p>核心知识点：</p>
<ol>
<li>CBOW和Skip-gram两个语言模型</li>
<li>层次softmax 和负采样两个技术</li>
</ol>
<p>首先初读：<br><a href="https://www.zhihu.com/question/44832436" target="_blank" rel="noopener">word2vec是如何得到词向量的？ 知乎</a></p>
<p>然后深入读和实践：</p>
<ol>
<li><a href="https://www.cnblogs.com/peghoty/p/3857839.html" target="_blank" rel="noopener">word2vec 中的数学原理详解（作者：peghoty 完整看完对理解w2v很有帮助）</a></li>
<li><a href="https://github.com/chenbjin/RepresentationLearning/blob/2e559bfa062ec9570fbe42f910e7dc3549de4d4c/Word2vec/word2vec.c#L587" target="_blank" rel="noopener">附带注释的 word2vec 源码（作者：chenbjin）</a></li>
<li><a href="https://blog.csdn.net/google19890102/article/details/51887344" target="_blank" rel="noopener">word2vec源码解析（作者：google19890102）</a></li>
</ol>
<hr>
<h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><h3 id="CNN中的局部连接-Sparse-Connectivity-和权值共享"><a href="#CNN中的局部连接-Sparse-Connectivity-和权值共享" class="headerlink" title="CNN中的局部连接(Sparse Connectivity)和权值共享"></a>CNN中的局部连接(Sparse Connectivity)和权值共享</h3><p><img src="/2019/08/16/机器学习中的常识性问题/神经网络全连接与局部连接对比图.jpg" alt=""></p>
<p>左边是全连接，右边是局部连接。对于一个1000 × 1000的输入图像而言，如果下一个隐藏层的神经元数目为10^6个，采用全连接则有1000 × 1000 × 10^6 = 10^12个权值参数，如此数目巨大的参数几乎难以训练；而采用局部连接，隐藏层的每个神经元仅与图像中10 × 10的局部图像相连接，那么此时的权值参数数量为10 × 10 × 10^6 = 10^8，将直接减少4个数量级。</p>
<p>尽管减少了几个数量级，但参数数量依然较多。能不能再进一步减少呢？能！方法就是权值共享。具体做法是，在局部连接中隐藏层的每一个神经元连接的是一个10 × 10的局部图像，因此有10 × 10个权值参数，将这10 × 10个权值参数共享给剩下的神经元，也就是说隐藏层中10^6个神经元的权值参数相同，那么此时不管隐藏层神经元的数目是多少，需要训练的参数就是这 10 × 10个权值参数（也就是卷积核(也称滤波器)的大小），如下图。</p>
<p><img src="/2019/08/16/机器学习中的常识性问题/神经网络局部连接和特征图.jpg" alt=""></p>
<p>但是，这样仅提取了图像的一种特征，如果要多提取出一些特征，可以增加多个卷积核，不同的卷积核能够得到图像的不同映射下的特征，称之为Feature Map。如果有100个卷积核，最终的权值参数也仅为100 × 100 = 10^4个而已。另外，偏置参数也是共享的，同一种滤波器共享一个。</p>
<p>卷积神经网络的核心思想是：局部感受野(local field)，权值共享以及时间或空间亚采样这三种思想结合起来，获得了某种程度的位移、尺度、形变不变性</p>
<h3 id="使用更小卷积核的作用"><a href="#使用更小卷积核的作用" class="headerlink" title="使用更小卷积核的作用"></a>使用更小卷积核的作用</h3><p>在VGG16中，使用了3个3x3卷积核来代替7x7卷积核，使用了2个3x3卷积核来代替5x5卷积核，这样做的主要目的是在保证具有相同感知野的条件下，提升了网络的深度，在一定程度上提升了神经网络的效果。</p>
<p>以下简单地说明一下小卷积(3*3)对于5×5网络感知野相同的替代性。</p>
<p><img src="https://img-blog.csdn.net/20171022172015402?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGluZ3p1aHVpdG91/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<hr>
<h2 id="机器学习中的杂项问题"><a href="#机器学习中的杂项问题" class="headerlink" title="机器学习中的杂项问题"></a>机器学习中的杂项问题</h2><h3 id="机器学习、深度学习、强化学习之间的关系"><a href="#机器学习、深度学习、强化学习之间的关系" class="headerlink" title="机器学习、深度学习、强化学习之间的关系"></a>机器学习、深度学习、强化学习之间的关系</h3><p><img src="/2019/08/16/机器学习中的常识性问题/机器学习深度学习强化学习之间的关系.png" alt=""><br>图片来自论文 <a href="https://arxiv.org/abs/1810.06339" target="_blank" rel="noopener">Deep Reinforcement Learning</a></p>
<p>机器学习研究如何使计算机系统利用经验改善性能。它是人工智能领域的分支，也是实现人工智能的一种手段。在机器学习的众多研究方向中，表征学习关注如何自动找出表示数据的合适方式，以便更好地将输入变换为正确的输出。在每一级（从原始数据开始），深度学习通过简单的函数将该级的表示变换为更高级的表示。因此，深度学习模型也可以看作是由许多简单函数复合而成的函数。当这些复合的函数足够多时，深度学习模型就可以表达非常复杂的变换。</p>
<p>深度学习可以逐级表示越来越抽象的概念或模式，以及端到端的训练。相对其它经典的机器学习方法而言，深度学习的不同在于：对非最优解的包容、对非凸非线性优化的使用，以及勇于尝试没有被证明过的方法。这种在处理统计问题上的新经验主义吸引了大量人才的涌入，使得大量实际问题有了更好的解决方案。</p>
<h3 id="自然语言处理与机器学习的关系"><a href="#自然语言处理与机器学习的关系" class="headerlink" title="自然语言处理与机器学习的关系"></a>自然语言处理与机器学习的关系</h3><p>点击下载自然语言处理与机器学习的<a href="https://raw.githubusercontent.com/wiki/hankcs/HanLP/img/mindmap.jpg" target="_blank" rel="noopener">双生树</a>图。该图来自面向生产环境的自然语言处理工具包 <a href="http://hanlp.com/" target="_blank" rel="noopener">HanLP</a></p>
<h3 id="举例说明深度学习、机器学习在商业中的实际应用？"><a href="#举例说明深度学习、机器学习在商业中的实际应用？" class="headerlink" title="举例说明深度学习、机器学习在商业中的实际应用？"></a>举例说明深度学习、机器学习在商业中的实际应用？</h3><p>参见 <a href="https://yuanxiaosc.github.io/2019/09/11/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%95%86%E4%B8%9A%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/">深度学习算法的商业应用案例</a></p>
<h3 id="机器学习“判定模型”和“生成模型”有什么区别？"><a href="#机器学习“判定模型”和“生成模型”有什么区别？" class="headerlink" title="机器学习“判定模型”和“生成模型”有什么区别？"></a>机器学习“判定模型”和“生成模型”有什么区别？</h3><p><a href="https://www.zhihu.com/question/20446337" target="_blank" rel="noopener">机器学习“判定模型”和“生成模型”有什么区别？ 知乎详解</a></p>
<p><strong>第一层理解</strong><br><img src="https://pic2.zhimg.com/80/v2-a2e753542fc6384ee351cabdbe6dd523_hd.jpg" alt=""><br>其实机器学习的任务是从属性X预测标记Y，即求概率P(Y|X)；对于判别式模型来说求得P(Y|X)，对未见示例X，根据P(Y|X)可以求得标记Y，即可以直接判别出来，如上图的左边所示，实际是就是直接得到了判别边界，所以传统的、耳熟能详的机器学习算法如线性回归模型、支持向量机SVM等都是判别式模型，这些模型的特点都是输入属性X可以直接得到Y（对于二分类任务来说，实际得到一个score，当score大于threshold时则为正类，否则为反类）</p>
<p>而生成式模型求得P(Y,X)，对于未见示例X，你要求出X与不同标记之间的联合概率分布，然后大的获胜，如上图右边所示，并没有什么边界存在，对于未见示例（红三角），求两个联合概率分布（有两个类），比较一下，取那个大的。</p>
<p><strong>在机器学习中任务是从属性X预测标记Y，判别模型求的是P(Y|X)，即后验概率；而生成模型最后求的是P(X,Y)，即联合概率</strong>。从本质上来说：判别模型之所以称为“判别”模型，是因为其根据X“判别”Y；而生成模型之所以称为“生成”模型，是因为其预测的根据是联合概率P(X,Y)，而联合概率可以理解为“生成”(X,Y)样本的概率分布（或称为 依据）；具体来说，机器学习已知X，从Y的候选集合中选出一个来，可能的样本有(X,Y_1), (X,Y_2), (X,Y_3),……，(X,Y_n),实际数据是如何“生成”的依赖于P(X,Y)，那么最后的预测结果选哪一个Y呢？那就选“生成”概率最大的那个吧~</p>
<p><strong>第二层理解</strong><br><img src="/2019/08/16/机器学习中的常识性问题/机器学习“判定模型”和“生成模型”有什么区别？.png" alt=""></p>
<p><strong>第三层理解</strong><br>首先区分生成/判别方法和生成/判别模型。<br>有监督机器学习方法可以分为生成方法和判别方法（常见的生成方法有LDA主题模型、朴素贝叶斯算法和隐式马尔科夫模型等，常见的判别方法有SVM、LR等），生成方法学习出的是生成模型，判别方法学习出的是判别模型。</p>
<p><img src="/2019/08/16/机器学习中的常识性问题/机器学习“判定模型”和“生成模型”有什么区别？_1.png" alt=""><br><img src="/2019/08/16/机器学习中的常识性问题/机器学习“判定模型”和“生成模型”有什么区别？_2.png" alt=""></p>
<h3 id="概率与logit（几率）的关系"><a href="#概率与logit（几率）的关系" class="headerlink" title="概率与logit（几率）的关系"></a>概率与logit（几率）的关系</h3><p><a href="https://en.wikipedia.org/wiki/Logit" target="_blank" rel="noopener">Logit 维基百科</a></p>
<p><img src="/2019/08/16/机器学习中的常识性问题/概率与logit的关系.png" alt=""></p>
<h3 id="Logit模型和Logistic模型的区别与联系？"><a href="#Logit模型和Logistic模型的区别与联系？" class="headerlink" title="Logit模型和Logistic模型的区别与联系？"></a>Logit模型和Logistic模型的区别与联系？</h3><p><img src="/2019/08/16/机器学习中的常识性问题/Logit模型和Logistic模型的区别与联系.png" alt=""></p>
<h3 id="Logistic回归中的Logit函数和sigmoid函数的关系？"><a href="#Logistic回归中的Logit函数和sigmoid函数的关系？" class="headerlink" title="Logistic回归中的Logit函数和sigmoid函数的关系？"></a>Logistic回归中的Logit函数和sigmoid函数的关系？</h3><p><img src="/2019/08/16/机器学习中的常识性问题/Logistic回归中的Logit函数和sigmoid函数.png" alt=""></p>
<h3 id="逻辑回归与线性回归的区别与联系？"><a href="#逻辑回归与线性回归的区别与联系？" class="headerlink" title="逻辑回归与线性回归的区别与联系？"></a>逻辑回归与线性回归的区别与联系？</h3><p>本质区别：逻辑回归处理的是分类问题，线性回归处理的是回归问题。<br>联系：如果把一个事件的几率（odd）定义为该事件发生的概率与该事件不发生的概率的比值$\dfrac {p}{1-p}$，那么逻辑回归可以看作是对于“y=1|x”（将输入x预测为正样本的概率）这一事件的对数几率的线性回归。</p>
<p><img src="/2019/08/16/机器学习中的常识性问题/逻辑回归与线性回归的区别与联系.png" alt=""></p>
<h3 id="模型在验证集的测试指标优于在训练集的指标的原因是什么？"><a href="#模型在验证集的测试指标优于在训练集的指标的原因是什么？" class="headerlink" title="模型在验证集的测试指标优于在训练集的指标的原因是什么？"></a>模型在验证集的测试指标优于在训练集的指标的原因是什么？</h3><p>主要因素是因为像 BatchNormalization 和 Dropout 这样的层会影响训练期间的准确性。在计算验证损失时，它们会被关闭。</p>
<p>在较小程度上，这也是因为训练指标报告了一个周期的平均值，而验证指标是在周期之后进行评估的，因此验证指标体现的是已经训练稍长一些的模型。</p>
<h3 id="计算机视觉迁移学习中的特征提取和微调的区别和联系"><a href="#计算机视觉迁移学习中的特征提取和微调的区别和联系" class="headerlink" title="计算机视觉迁移学习中的特征提取和微调的区别和联系"></a>计算机视觉迁移学习中的特征提取和微调的区别和联系</h3><p>特征提取：使用先前网络学习的表示从新样本中提取有意义的特征。您只需在预训练模型的基础上添加一个新的分类器（将从头开始训练），以便您可以重新调整先前为我们的数据集学习的特征映射。您不需要（重新）训练整个模型。基本卷积网络已经包含通常用于分类图片的功能。然而，预训练模型的最终分类部分特定于原始分类任务，并且随后特定于训练模型的类集。</p>
<p>微调：冻结冻结模型库的一些顶层，并共同训练新添加的分类器层和基础模型的最后一层。这允许我们“微调”基础模型中的高阶特征表示，以使它们与特定任务更相关。</p>
<p>使用预先训练的模型进行特征提取：使用小型数据集时，通常会利用在同一域中的较大数据集上训练的模型所学习的特征。这是通过实例化预先训练的模型并在顶部添加完全连接的分类器来完成的。预训练的模型被“冻结”并且仅在训练期间更新分类器的权重。在这种情况下，卷积基础提取了与每个图像相关的所有特征，并且您刚刚训练了一个分类器，该分类器根据提取的特征集确定图像类。</p>
<p>微调预先训练的模型：为了进一步提高性能，可能需要通过微调将预训练模型的顶层重新调整为新数据集。在这种情况下，您调整了权重，以便模型学习特定于数据集的高级特征。当训练数据集很大并且非常类似于训练预训练模型的原始数据集时，通常建议使用此技术。</p>
<h3 id="TF-IDF的定义、计算公式、应用和优缺点分别是什么？"><a href="#TF-IDF的定义、计算公式、应用和优缺点分别是什么？" class="headerlink" title="TF-IDF的定义、计算公式、应用和优缺点分别是什么？"></a>TF-IDF的定义、计算公式、应用和优缺点分别是什么？</h3><p>TF-IDF有两层意思，一层是”词频”（Term Frequency，缩写为TF），另一层是”逆文档频率”（Inverse Document Frequency，缩写为IDF）。TF-IDF(term frequency–inverse document frequency)是一种用于信息检索与数据挖掘的常用加权技术，常用于挖掘文章中的关键词，而且算法简单高效，常被工业用于最开始的文本数据清洗。</p>
<p><img src="/2019/08/16/机器学习中的常识性问题/TF-IDF算法步骤.png" alt=""></p>
<p>TF-IDF提取文档关键词的优缺点：<br>TF-IDF的优点是简单快速，而且容易理解。缺点是有时候用词频来衡量文章中的一个词的重要性不够全面，有时候重要的词出现的可能不够多，而且这种计算无法体现位置信息，无法体现词在上下文的重要性。</p>
<p>TF-IDF的应用（后文一一举例说明）：</p>
<ul>
<li>提取文章关键词</li>
<li>确定文章相似性（结合余弦相似性）</li>
<li>自动摘要</li>
</ul>
<p><a href="http://www.ruanyifeng.com/blog/2013/03/tf-idf.html" target="_blank" rel="noopener">TF-IDF与余弦相似性的应用（一）：自动提取关键词</a><br><img src="/2019/08/16/机器学习中的常识性问题/TF-IDF的应用——提取关键词.png" alt=""></p>
<p><a href="http://www.ruanyifeng.com/blog/2013/03/cosine_similarity.html" target="_blank" rel="noopener">TF-IDF与余弦相似性的应用（二）：找出相似文章</a><br>（1）使用TF-IDF算法，找出两篇文章的关键词；<br>（2）每篇文章各取出若干个关键词（比如20个），合并成一个集合，计算每篇文章对于这个集合中的词的词频（为了避免文章长度的差异，可以使用相对词频）；<br>（3）生成两篇文章各自的词频向量；<br>（4）计算两个向量的余弦相似度，值越大就表示越相似。</p>
<p><a href="http://www.ruanyifeng.com/blog/2013/03/automatic_summarization.html" target="_blank" rel="noopener">TF-IDF与余弦相似性的应用（三）：自动摘要</a><br>如果能从3000字的文章，提炼出150字的摘要，就可以为读者节省大量阅读时间。由人完成的摘要叫”人工摘要”，由机器完成的就叫”自动摘要”。其中，很重要的一种自动摘要技术就是词频统计。其实一种方法就是抽取文章中含有一定量关键词的句子。</p>
<h3 id="BM25的定义、计算公式、应用和优缺点分别是什么？"><a href="#BM25的定义、计算公式、应用和优缺点分别是什么？" class="headerlink" title="BM25的定义、计算公式、应用和优缺点分别是什么？"></a>BM25的定义、计算公式、应用和优缺点分别是什么？</h3><p><a href="https://blog.csdn.net/weixin_41090915/article/details/79053584" target="_blank" rel="noopener">自然语言处理-BM25相关度打分</a></p>
<h3 id="如何提取文本关键词？"><a href="#如何提取文本关键词？" class="headerlink" title="如何提取文本关键词？"></a>如何提取文本关键词？</h3><p><a href="https://zhuanlan.zhihu.com/p/49049482" target="_blank" rel="noopener">文本关键词提取算法总结和Python实现</a><br><img src="/2019/08/16/机器学习中的常识性问题/提取文本关键词的方法.png" alt=""><br>文本关键词提取算法大致分为有监督和无监督两种：</p>
<ol>
<li>有监督算法将关键词抽取问题转换为判断每个候选关键词是否为关键词的二分类问题，它需要一个已经标注关键词的文档集合训练分类模型。</li>
<li>无监督算法不需要人工标注的训练集，利用某些方法发现文本中比较重要的词作为关键词，进行关键词抽取。词重要性的衡量有多种方式：基于文本统计特征、基于词图模型和基于主题模型，TF-IDF、TextRank和LDA分别是这几种不同方式的代表</li>
</ol>
<p><strong>TF-IDF关键词提取</strong><br><img src="/2019/08/16/机器学习中的常识性问题/TF-IDF关键词提取.png" alt=""></p>
<p><strong>TextRank关键词抽取</strong><br>PageRank算法将整个互联网看作一张有向图，网页是图中的节点，而网页之间的链接就是途中的边。根据重要性传递的思想，如果一个网页A含有一个指向网页B的链接，那么网页B的重要性排名会根据A的重要行来提升。<br>在PageRank算法中，对于网页初始重要值（PR值）的计算非常关键，但是这个值无法预知，于是PageRank论文中给出了一种迭代算法求出这个PR值：为每个网页随机给一个初始值，然后迭代得到收敛值，作为网页重要性的度量。</p>
<p><img src="/2019/08/16/机器学习中的常识性问题/TextRank关键词抽取.png" alt=""></p>
<p><strong>LDA（Latent Dirichlet Allocation）关键词抽取</strong><br>LDA的这三位作者在原始论文 <a href="http://www.jmlr.org/papers/volume3/blei03a/blei03a.pdf" target="_blank" rel="noopener">Latent Dirichlet Allocation</a> 中给了一个简单的例子。比如假设事先给定了这几个主题：Arts、Budgets、Children、Education，然后通过学习的方式，获取每个主题Topic对应的词语（我们可以认为这些主题词语就是关键词）。如下图所示：</p>
<p><img src="/2019/08/16/机器学习中的常识性问题/LDA主题模型例子.jpeg" alt=""></p>
<p>然后以一定的概率选取上述某个主题，再以一定的概率生成选取主题下的某个单词，不断的重复这两步，最终生成如下图所示的一篇文章（其中不同颜色的词语分别对应上图中不同主题下的词）：</p>
<p><img src="/2019/08/16/机器学习中的常识性问题/LDA主题模型例子2.jpeg" alt=""></p>
<p>而当我们看到一篇文章后，往往喜欢推测这篇文章是如何生成的，我们可能会认为作者先确定这篇文章的几个主题，然后围绕这几个主题遣词造句，表达成文。LDA就是要干这事：根据给定的一篇文档，推测其主题分布。</p>
<hr>
<h2 id="如何处理数据类别不平衡问题"><a href="#如何处理数据类别不平衡问题" class="headerlink" title="如何处理数据类别不平衡问题"></a>如何处理数据类别不平衡问题</h2><p>当一个分类任务的数据集中来自不同类别的样本数目相差悬殊时，我们通常称该数据集为“类别不平衡”的。以一个现实任务为例：在点击率预估（click-through rate prediction）任务中，每条展示给用户的广告都产生一条新样本，而用户最终是否点击了这条广告决定了样本的标签。显然，只有很少一部分的用户会去点击网页里的嵌入广告，这就导致最终得到的训练数据集中正/负例样本的数量差距悬殊。同样的情况也发生在很多实际应用场景中，如金融欺诈检测（正常/欺诈），医疗辅助诊断（正常/患病），网络入侵检测（正常连接/攻击连接）等等。 需要注意的是，尽管少数类的样本个数更少，表示的质量也更差，但其通常会携带更重要的信息，因此一般我们更关注模型正确分类少数类样本的能力。</p>
<p>分类问题的一个underlying assumption是各个类别的数据都有自己的分布，当某类数据少到难以观察结构的时候，我们可以考虑抛弃该类数据，转而学习更为明显的多数类模式，而后将不符合多数类模式的样本判断为异常/少数类，某些时候会有更好的效果。此时该问题退化为异常检测（anomaly detection）问题。</p>
<p>我将已有的不平衡学习算法划分为3类：数据级方法，算法级方法以及集成方法（参考<a href="https://www.jiqizhixin.com/articles/2019-06-18-5" target="_blank" rel="noopener">极端类别不平衡数据下的分类问题研究综述</a>）。</p>
<h3 id="数据级方法"><a href="#数据级方法" class="headerlink" title="数据级方法"></a>数据级方法</h3><p>数据级方法是不平衡学习领域发展最早、影响力最大、使用最广泛的一类方法，也可称为重采样方法。该类方法关注于通过修改训练数据集以使得标准学习算法也能在其上有效训练。根据实现方式的不同，数据级方法可被进一步分类为：</p>
<ol>
<li>从多数类别中删除样本的方法（欠采样）</li>
<li>为少数类别生成新样本的方法（过采样）</li>
<li>结合上述两种方案的混合类方法（过采样+欠采样去噪）</li>
</ol>
<p>标准的随机重采样方法使用随机方法来选择用于预处理的目标样本。然而随机方法可能会导致丢弃含有重要信息的样本（随机欠采样）或者引入无意义的甚至有害的新样本（随机过采样），因此有一系列更高级的方法，试图根据根据数据的分布信息来在进行重采样的同时保持原有的数据结构。</p>
<p>数据级方法Strength</p>
<ol>
<li>该类方法能够去除噪声/平衡类别分布：在重采样后的数据集上训练可以提高某些分类器的分类性能。</li>
<li>欠采样方法减小数据集规模：欠采样方法会去除一些多数类样本，从而可能降低模型训练时的计算开销。</li>
</ol>
<p>数据级方法Weakness</p>
<ol>
<li>采样过程计算效率低下：这一系列的“高级”重采样方法通常使用基于距离的邻域关系（通常是k-最近邻方法）来提取数据分布信息。该方式的缺点是需要计算每个数据样本之间的距离，而计算距离需要的计算量随着数据集的大小呈平方级增长，因此在大规模数据集上应用这些方法可能会带来极低的计算效率。</li>
<li>易被噪声影响：此外在具有高不平衡比且包含大量噪声的工业数据集中，少数类的结构可能并不能被样本的分布很好地表示。而被这些重采样方法用来提取分布信息的最近邻算法很容易被噪声干扰，因此可能无法得到准确的分布信息，从而导致不合理的重采样策略。</li>
<li>过采样方法生成过多数据：当应用于大规模且高度不平衡的数据集时，过采样类的方法可能会生成大量的少数类样本以平衡数据集。这会进一步增大训练集的样本数量，增大计算开销，减慢训练速度，并可能导致过拟合。</li>
<li>不适用于无法计算距离的复杂数据集：最重要的一点是这些重采样方法依赖于明确定义的距离度量，使得它们在某些数据集上不可用。在实际应用中，工业数据集经常会含有类别特征（即不分布在连续空间上的特征，如用户ID）或者缺失值，此外不同特征的取值范围可能会有巨大的差别。在这些数据集上定义合理的距离度量十分困难。</li>
</ol>
<h3 id="算法级方法"><a href="#算法级方法" class="headerlink" title="算法级方法"></a>算法级方法</h3><p>算法级方法专注于修改现有的标准机器学习算法以修正他们对多数类的偏好。在这类方法中最流行的分支是代价敏感学习（cost-sensitive learning），我们在此也只讨论该类算法。代价敏感学习给少数类样本分配较高的误分类代价，而给多数类样本分配较小的误分类代价。通过这种方式代价敏感学习在学习器的训练过程中人为提高了少数类别样本的重要性，以此减轻分类器对多数类的偏好。</p>
<p>算法级方法Strength</p>
<ol>
<li>不增加训练复杂度：使用该类算法改进后的算法通常会有更好的表现，并且没有增加训练的计算复杂度。</li>
<li>可直接用于多分类问题：该类算法通常只修改误分类代价，因此可直接扩展到多分类问题上。</li>
</ol>
<p>算法级方法Weakness</p>
<ol>
<li>需要领域先验知识：必须注意的是，代价敏感学习中的代价矩阵（cost matrix）需要由领域专家根据任务的先验知识提供，这在许多现实问题中显然是不可用的。因此在实际应用时代价矩阵通常被直接设置为归一化的不同类别样本数量比。由于缺乏领域知识的指导，这种擅自设置的代价矩阵并不能保证得到最优的分类性能。</li>
<li>不能泛化到不同任务：对于特定问题设计的代价矩阵只能用于该特定任务，在其他任务上使用时并不能保证良好的性能表现。</li>
<li>依赖于特定分类器：另一方面，对于诸如神经网络的需要以批次训练（mini-batch training）方法训练的模型，少数类样本仅仅存在于在很少的批次中，而大部分批次中只含有多数类样本，这会给神经网络训练带来灾难性的后果：使用梯度下降更新的非凸优化过程会很快陷入局部极值点/鞍点（梯度为0），导致网络无法进行有效学习。使用敏感代价学习来给样本加权并不能解决这个问题。</li>
</ol>
<h3 id="集成学习的方法"><a href="#集成学习的方法" class="headerlink" title="集成学习的方法"></a>集成学习的方法</h3><p>集成学习类方法专注于将一种数据级或算法级方法与集成学习相结合，以获得强大的集成分类器。由于其在类别不平衡任务中表现出色，在实际应用中集成学习越来越受欢迎。</p>
<h3 id="处理数据类别不平衡问题的工具："><a href="#处理数据类别不平衡问题的工具：" class="headerlink" title="处理数据类别不平衡问题的工具："></a>处理数据类别不平衡问题的工具：</h3><p><a href="https://github.com/scikit-learn-contrib/imbalanced-learn" target="_blank" rel="noopener">imbalanced-learn</a> A Python Package to Tackle the Curse of Imbalanced Datasets in Machine Learning</p>
<p><strong>附加阅读</strong></p>
<ul>
<li><a href="https://www.jiqizhixin.com/articles/021704?from=synced&amp;keyword=%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E5%B9%B3%E8%A1%A1%E7%B1%BB%E4%B8%8A%E4%BD%BF%E7%94%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9F" target="_blank" rel="noopener">机器学习中如何处理不平衡数据？</a></li>
<li><a href="https://www.leiphone.com/news/201807/n29cU8N7Jk5w0K7E.html" target="_blank" rel="noopener">深度学习训练数据不平衡问题，怎么解决？</a></li>
<li><a href="https://www.cnblogs.com/jiqibuxuexi/p/8416770.html" target="_blank" rel="noopener">机器不学习：如何处理数据中的「类别不平衡」？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;mid=2650718717&amp;idx=1&amp;sn=85038d7c906c135120a8e1a2f7e565ad&amp;scene=0#wechat_redirect" target="_blank" rel="noopener">深度 | 解决真实世界问题：如何在不平衡类上使用机器学习？</a></li>
</ul>
<hr>
<h2 id="如何计算文本之间的相似度？"><a href="#如何计算文本之间的相似度？" class="headerlink" title="如何计算文本之间的相似度？"></a>如何计算文本之间的相似度？</h2><p>TODO: 完善内容</p>
<p><strong>计算文本相似度的算法</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>一级分类</th>
<th>二级分类</th>
</tr>
</thead>
<tbody>
<tr>
<td>基于词向量</td>
<td>欧几里德距离、曼哈顿距离和余弦距离、明式距离、切比雪夫距离等</td>
</tr>
<tr>
<td>基于具体字符</td>
<td>共有字符数、汉明距离、编辑距离、SimHash</td>
</tr>
<tr>
<td>基于概率统计</td>
<td>杰卡德相似系数</td>
</tr>
<tr>
<td>基于统计学习模型的</td>
<td>主题模型（潜在语义分析LSA、潜在狄利克雷分布LDA）</td>
</tr>
<tr>
<td>基于深度学习模型的</td>
<td>doc2vec,word2vec</td>
</tr>
</tbody>
</table>
</div>
<p><a href="https://blog.csdn.net/huanghanqian/article/details/78732392" target="_blank" rel="noopener">NLP点滴——文本相似度，计算文本间的距离</a></p>
<h3 id="短文本之间的相似度"><a href="#短文本之间的相似度" class="headerlink" title="短文本之间的相似度"></a>短文本之间的相似度</h3><p><a href="https://blog.csdn.net/weiyudang11/article/details/52402867" target="_blank" rel="noopener">短文本相似度度量</a></p>
<h3 id="如何设计一个比较海量文章相似度的算法？"><a href="#如何设计一个比较海量文章相似度的算法？" class="headerlink" title="如何设计一个比较海量文章相似度的算法？"></a>如何设计一个比较海量文章相似度的算法？</h3><ul>
<li><a href="https://blog.csdn.net/lengye7/article/details/79789206" target="_blank" rel="noopener">simhash算法及原理简介</a></li>
<li><a href="https://yuerblog.cc/2018/05/30/simhash-text-unique-arch/" target="_blank" rel="noopener">simhash海量文本去重的工程化</a></li>
</ul>
<p>SimHash是Google在2007年发表的论文《Detecting Near-Duplicates for Web Crawling 》中提到的一种指纹生成算法或者叫指纹提取算法，被Google广泛应用在亿级的网页去重的Job中，作为locality sensitive hash（局部敏感哈希）的一种。其主要思想是降维，将高维的特征向量映射成低维的特征向量，通过两个向量的Hamming Distance来确定文章是否重复或者高度近似。其中，Hamming Distance，又称汉明距离，在信息论中，两个等长字符串之间的汉明距离是两个字符串对应位置的不同字符的个数。也就是说，它就是将一个字符串变换成另外一个字符串所需要替换的字符个数。例如：1011101 与 1001001 之间的汉明距离是 2。至于我们常说的字符串编辑距离则是一般形式的汉明距离。</p>
<p><img src="/2019/08/16/机器学习中的常识性问题/simhash.jpg" alt=""><br><img src="/2019/08/16/机器学习中的常识性问题/SimHash算法例子.png" alt=""></p>
<h3 id="机器学习中距离和相似性度量方法"><a href="#机器学习中距离和相似性度量方法" class="headerlink" title="机器学习中距离和相似性度量方法"></a>机器学习中距离和相似性度量方法</h3><p><a href="https://www.cnblogs.com/daniel-D/p/3244718.html" target="_blank" rel="noopener">漫谈：机器学习中距离和相似性度量方法</a></p>
<p>参见<a href="https://baike.baidu.com/item/度量/19835060" target="_blank" rel="noopener">度量 百度百科</a>。距离函数（度量）需要满足三条性质：正定性、对称性和三角不等式。</p>
<hr>
<h2 id="如何解决冷启动问题"><a href="#如何解决冷启动问题" class="headerlink" title="如何解决冷启动问题"></a>如何解决冷启动问题</h2><h3 id="如何用主体模型解决推荐系统中的冷启动问题？"><a href="#如何用主体模型解决推荐系统中的冷启动问题？" class="headerlink" title="如何用主体模型解决推荐系统中的冷启动问题？"></a>如何用主体模型解决推荐系统中的冷启动问题？</h3><p><img src="/2019/08/16/机器学习中的常识性问题/用主体模型解决推荐系统中的冷启动问题.png" alt=""><br><img src="/2019/08/16/机器学习中的常识性问题/用主体模型解决推荐系统中的冷启动问题2.png" alt=""></p>
<hr>
<h2 id="下一步学习，终生学习"><a href="#下一步学习，终生学习" class="headerlink" title="下一步学习，终生学习"></a>下一步学习，终生学习</h2><h3 id="机器学习十大经典算法"><a href="#机器学习十大经典算法" class="headerlink" title="机器学习十大经典算法"></a>机器学习十大经典算法</h3><ul>
<li><a href="https://zhuanlan.zhihu.com/p/59767178" target="_blank" rel="noopener">机器学习必学10大算法</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/46831267" target="_blank" rel="noopener">机器学习算法优缺点对比及选择（汇总篇）</a></li>
<li><a href="https://www.cnblogs.com/bonelee/p/7834026.html" target="_blank" rel="noopener">机器学习算法选择</a></li>
</ul>
<h3 id="机器学习中的500问"><a href="#机器学习中的500问" class="headerlink" title="机器学习中的500问"></a>机器学习中的500问</h3><p>系统性学习机器学习中的问题，参见 <a href="https://github.com/scutan90/DeepLearning-500-questions" target="_blank" rel="noopener">深度学习500问</a>。</p>
<h3 id="机器学习、深度学习框架"><a href="#机器学习、深度学习框架" class="headerlink" title="机器学习、深度学习框架"></a>机器学习、深度学习框架</h3><p>速览TensorFlow 基本概念 <a href="https://github.com/taki0112/Tensorflow-Cookbook" target="_blank" rel="noopener">Tensorflow-Cookbook</a></p>
<h3 id="自然语言处理的技术路线"><a href="#自然语言处理的技术路线" class="headerlink" title="自然语言处理的技术路线"></a>自然语言处理的技术路线</h3><p>详细内容见 <a href="https://github.com/graykode/nlp-roadmap" target="_blank" rel="noopener">nlp-roadmap</a></p>
<p>自然语言处理路线图详解，从数学基础、语言基础到模型和算法，这是你该了解的知识领域。</p>

    </div>

    
    
    
        
      
        <div id="reward-container">
  <div>本站所有文章和源码均免费开放，如您喜欢，可以请我喝杯咖啡</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.jpg" alt="袁宵 微信支付">
        <p>微信支付</p>
      </div>
        
      
      <div style="display: inline-block">
        <img src="/images/alipay.jpg" alt="袁宵 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

      
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>袁宵</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/" title="机器学习中的常识性问题">https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>
</div>

      

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/08/05/异常检测/" rel="next" title="异常检测">
                  <i class="fa fa-chevron-left"></i> 异常检测
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/08/18/中文文本纠错/" rel="prev" title="中文文本纠错">
                  中文文本纠错 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一名合格的算法工程师是怎样的"><span class="nav-number">1.</span> <span class="nav-text">一名合格的算法工程师是怎样的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#真算法工程师与调包侠的区别与联系？"><span class="nav-number">1.1.</span> <span class="nav-text">真算法工程师与调包侠的区别与联系？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解决机器学习问题的工作流程"><span class="nav-number">2.</span> <span class="nav-text">解决机器学习问题的工作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#以文本分类为例说明解决机器学习问题的工作流程"><span class="nav-number">2.1.</span> <span class="nav-text">以文本分类为例说明解决机器学习问题的工作流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#机器学习中的集成方法"><span class="nav-number">3.</span> <span class="nav-text">机器学习中的集成方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bagging（bootstrap-aggregating，装袋）"><span class="nav-number">3.1.</span> <span class="nav-text">Bagging（bootstrap aggregating，装袋）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Boosting"><span class="nav-number">3.2.</span> <span class="nav-text">Boosting</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从基于树的算法的演变过程看集成学习"><span class="nav-number">3.3.</span> <span class="nav-text">从基于树的算法的演变过程看集成学习</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XGBoost"><span class="nav-number">3.4.</span> <span class="nav-text">XGBoost</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模型训练、预测与评估的关系"><span class="nav-number">4.</span> <span class="nav-text">模型训练、预测与评估的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深度学习中的基础模型结构"><span class="nav-number">5.</span> <span class="nav-text">深度学习中的基础模型结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#画出循环神经网络中的RNN-cell、GRU、LSTM的结构图，并说明图中各部分的作用"><span class="nav-number">5.1.</span> <span class="nav-text">画出循环神经网络中的RNN_cell、GRU、LSTM的结构图，并说明图中各部分的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#画出Transformer的模型结构图，并说明图中各部分的作用"><span class="nav-number">5.2.</span> <span class="nav-text">画出Transformer的模型结构图，并说明图中各部分的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模型结构相关的计算题"><span class="nav-number">5.3.</span> <span class="nav-text">模型结构相关的计算题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#机器学习中的损失函数"><span class="nav-number">6.</span> <span class="nav-text">机器学习中的损失函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#交叉熵损失函数"><span class="nav-number">6.1.</span> <span class="nav-text">交叉熵损失函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两种形式的二分类交叉熵损失函数的推导"><span class="nav-number">6.2.</span> <span class="nav-text">两种形式的二分类交叉熵损失函数的推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么结合sigmoid激活函数和交叉熵损失函数能保证数值稳定？"><span class="nav-number">6.3.</span> <span class="nav-text">为什么结合sigmoid激活函数和交叉熵损失函数能保证数值稳定？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#机器学习中的优化算法"><span class="nav-number">7.</span> <span class="nav-text">机器学习中的优化算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#机器学习中的优化问题"><span class="nav-number">7.1.</span> <span class="nav-text">机器学习中的优化问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#经典优化算法"><span class="nav-number">7.2.</span> <span class="nav-text">经典优化算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SGD、AdaGrad、RMSProp、AdaDelta和Adam基于梯度的优化算法关系"><span class="nav-number">7.3.</span> <span class="nav-text">SGD、AdaGrad、RMSProp、AdaDelta和Adam基于梯度的优化算法关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#梯度下降"><span class="nav-number">7.4.</span> <span class="nav-text">梯度下降</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数加权移动平均与动量法"><span class="nav-number">7.5.</span> <span class="nav-text">数加权移动平均与动量法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AdaGrad算法"><span class="nav-number">7.6.</span> <span class="nav-text">AdaGrad算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RMSProp算法"><span class="nav-number">7.7.</span> <span class="nav-text">RMSProp算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AdaDelta算法"><span class="nav-number">7.8.</span> <span class="nav-text">AdaDelta算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Adam算法"><span class="nav-number">7.9.</span> <span class="nav-text">Adam算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在小批量梯度下降算法使用中的注意事项"><span class="nav-number">7.10.</span> <span class="nav-text">在小批量梯度下降算法使用中的注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锯齿现象（zig-zagging）"><span class="nav-number">7.11.</span> <span class="nav-text">锯齿现象（zig-zagging）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#牛顿法与拟牛顿法"><span class="nav-number">7.12.</span> <span class="nav-text">牛顿法与拟牛顿法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#牛顿法、梯度下降与最速下降法对比"><span class="nav-number">7.13.</span> <span class="nav-text">牛顿法、梯度下降与最速下降法对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最小二乘法"><span class="nav-number">7.14.</span> <span class="nav-text">最小二乘法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#机器学习中的激活函数"><span class="nav-number">8.</span> <span class="nav-text">机器学习中的激活函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Sigmoid"><span class="nav-number">8.1.</span> <span class="nav-text">Sigmoid</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tanh"><span class="nav-number">8.2.</span> <span class="nav-text">tanh</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReLU"><span class="nav-number">8.3.</span> <span class="nav-text">ReLU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leaky-ReLU"><span class="nav-number">8.4.</span> <span class="nav-text">Leaky ReLU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ELU"><span class="nav-number">8.5.</span> <span class="nav-text">ELU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gelu"><span class="nav-number">8.6.</span> <span class="nav-text">gelu</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Softmax"><span class="nav-number">8.7.</span> <span class="nav-text">Softmax</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#机器学习中的正则化方法"><span class="nav-number">9.</span> <span class="nav-text">机器学习中的正则化方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#L1-Normalization"><span class="nav-number">9.1.</span> <span class="nav-text">L1 Normalization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#L1-正则化使得模型参数具有稀疏性的原理是什么？"><span class="nav-number">9.2.</span> <span class="nav-text">L1 正则化使得模型参数具有稀疏性的原理是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#L2-Normalization"><span class="nav-number">9.3.</span> <span class="nav-text">L2 Normalization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Batch-Normalization"><span class="nav-number">9.4.</span> <span class="nav-text">Batch Normalization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Group-Normalization"><span class="nav-number">9.5.</span> <span class="nav-text">Group Normalization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对比BatchNorm、LayerNorm、InstanceNorm、GroupNorm"><span class="nav-number">9.6.</span> <span class="nav-text">对比BatchNorm、LayerNorm、InstanceNorm、GroupNorm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dropout"><span class="nav-number">9.7.</span> <span class="nav-text">Dropout</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#机器学习中的模型训练技巧"><span class="nav-number">10.</span> <span class="nav-text">机器学习中的模型训练技巧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#机器学习中的评价指标"><span class="nav-number">11.</span> <span class="nav-text">机器学习中的评价指标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二分类评价指标"><span class="nav-number">11.1.</span> <span class="nav-text">二分类评价指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#机器翻译（文本生成）评价指标"><span class="nav-number">11.2.</span> <span class="nav-text">机器翻译（文本生成）评价指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目标检测的评价指标IoU"><span class="nav-number">11.3.</span> <span class="nav-text">目标检测的评价指标IoU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图像分类评价指标TopK"><span class="nav-number">11.4.</span> <span class="nav-text">图像分类评价指标TopK</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#机器学习中的模型选择"><span class="nav-number">12.</span> <span class="nav-text">机器学习中的模型选择</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#交叉验证"><span class="nav-number">12.1.</span> <span class="nav-text">交叉验证</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#降维"><span class="nav-number">13.</span> <span class="nav-text">降维</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#主成分分析（PCA）"><span class="nav-number">13.1.</span> <span class="nav-text">主成分分析（PCA）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线性判别分析（LDA）"><span class="nav-number">13.2.</span> <span class="nav-text">线性判别分析（LDA）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主成分分析（PCA）与线性判别分析（LDA）区别与联系"><span class="nav-number">13.3.</span> <span class="nav-text">主成分分析（PCA）与线性判别分析（LDA）区别与联系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#语言模型"><span class="nav-number">14.</span> <span class="nav-text">语言模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#词向量、词嵌入与语言模型的关系？"><span class="nav-number">14.1.</span> <span class="nav-text">词向量、词嵌入与语言模型的关系？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#神经语言模型和统计语言模型有啥异同点？"><span class="nav-number">14.2.</span> <span class="nav-text">神经语言模型和统计语言模型有啥异同点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语言模型的评价指标-困惑度？"><span class="nav-number">14.3.</span> <span class="nav-text">语言模型的评价指标-困惑度？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LDA主题模型"><span class="nav-number">15.</span> <span class="nav-text">LDA主题模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#word2vector"><span class="nav-number">16.</span> <span class="nav-text">word2vector</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#卷积"><span class="nav-number">17.</span> <span class="nav-text">卷积</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CNN中的局部连接-Sparse-Connectivity-和权值共享"><span class="nav-number">17.1.</span> <span class="nav-text">CNN中的局部连接(Sparse Connectivity)和权值共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用更小卷积核的作用"><span class="nav-number">17.2.</span> <span class="nav-text">使用更小卷积核的作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#机器学习中的杂项问题"><span class="nav-number">18.</span> <span class="nav-text">机器学习中的杂项问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#机器学习、深度学习、强化学习之间的关系"><span class="nav-number">18.1.</span> <span class="nav-text">机器学习、深度学习、强化学习之间的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自然语言处理与机器学习的关系"><span class="nav-number">18.2.</span> <span class="nav-text">自然语言处理与机器学习的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#举例说明深度学习、机器学习在商业中的实际应用？"><span class="nav-number">18.3.</span> <span class="nav-text">举例说明深度学习、机器学习在商业中的实际应用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#机器学习“判定模型”和“生成模型”有什么区别？"><span class="nav-number">18.4.</span> <span class="nav-text">机器学习“判定模型”和“生成模型”有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#概率与logit（几率）的关系"><span class="nav-number">18.5.</span> <span class="nav-text">概率与logit（几率）的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Logit模型和Logistic模型的区别与联系？"><span class="nav-number">18.6.</span> <span class="nav-text">Logit模型和Logistic模型的区别与联系？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Logistic回归中的Logit函数和sigmoid函数的关系？"><span class="nav-number">18.7.</span> <span class="nav-text">Logistic回归中的Logit函数和sigmoid函数的关系？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逻辑回归与线性回归的区别与联系？"><span class="nav-number">18.8.</span> <span class="nav-text">逻辑回归与线性回归的区别与联系？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模型在验证集的测试指标优于在训练集的指标的原因是什么？"><span class="nav-number">18.9.</span> <span class="nav-text">模型在验证集的测试指标优于在训练集的指标的原因是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算机视觉迁移学习中的特征提取和微调的区别和联系"><span class="nav-number">18.10.</span> <span class="nav-text">计算机视觉迁移学习中的特征提取和微调的区别和联系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TF-IDF的定义、计算公式、应用和优缺点分别是什么？"><span class="nav-number">18.11.</span> <span class="nav-text">TF-IDF的定义、计算公式、应用和优缺点分别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BM25的定义、计算公式、应用和优缺点分别是什么？"><span class="nav-number">18.12.</span> <span class="nav-text">BM25的定义、计算公式、应用和优缺点分别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何提取文本关键词？"><span class="nav-number">18.13.</span> <span class="nav-text">如何提取文本关键词？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何处理数据类别不平衡问题"><span class="nav-number">19.</span> <span class="nav-text">如何处理数据类别不平衡问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据级方法"><span class="nav-number">19.1.</span> <span class="nav-text">数据级方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法级方法"><span class="nav-number">19.2.</span> <span class="nav-text">算法级方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集成学习的方法"><span class="nav-number">19.3.</span> <span class="nav-text">集成学习的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理数据类别不平衡问题的工具："><span class="nav-number">19.4.</span> <span class="nav-text">处理数据类别不平衡问题的工具：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何计算文本之间的相似度？"><span class="nav-number">20.</span> <span class="nav-text">如何计算文本之间的相似度？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#短文本之间的相似度"><span class="nav-number">20.1.</span> <span class="nav-text">短文本之间的相似度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何设计一个比较海量文章相似度的算法？"><span class="nav-number">20.2.</span> <span class="nav-text">如何设计一个比较海量文章相似度的算法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#机器学习中距离和相似性度量方法"><span class="nav-number">20.3.</span> <span class="nav-text">机器学习中距离和相似性度量方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何解决冷启动问题"><span class="nav-number">21.</span> <span class="nav-text">如何解决冷启动问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何用主体模型解决推荐系统中的冷启动问题？"><span class="nav-number">21.1.</span> <span class="nav-text">如何用主体模型解决推荐系统中的冷启动问题？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#下一步学习，终生学习"><span class="nav-number">22.</span> <span class="nav-text">下一步学习，终生学习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#机器学习十大经典算法"><span class="nav-number">22.1.</span> <span class="nav-text">机器学习十大经典算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#机器学习中的500问"><span class="nav-number">22.2.</span> <span class="nav-text">机器学习中的500问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#机器学习、深度学习框架"><span class="nav-number">22.3.</span> <span class="nav-text">机器学习、深度学习框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自然语言处理的技术路线"><span class="nav-number">22.4.</span> <span class="nav-text">自然语言处理的技术路线</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.png"
      alt="袁宵">
  <p class="site-author-name" itemprop="name">袁宵</p>
  <div class="site-description" itemprop="description">专注于机器学习前沿论文（技术）研究和应用，欢迎邮件交流。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives">
        
          <span class="site-state-item-count">143</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">57</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">127</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/yuanxiaoSC" title="GitHub &rarr; https://github.com/yuanxiaoSC" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:wangzichaochaochao@gmail.com" title="E-Mail &rarr; mailto:wangzichaochaochao@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>
  <div class="cc-license motion-element" itemprop="license">
    
  
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
	  

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">袁宵</span>
</div>
  <div class="addthis_inline_share_toolbox">
    <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5d9c4b1ac4deb418" async="async"></script>
  </div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">全站共 381.5k 字</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
  
</div>












        
      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.1"></script><script src="/js/motion.js?v=7.4.1"></script>
<script src="/js/schemes/pisces.js?v=7.4.1"></script>

<script src="/js/next-boot.js?v=7.4.1"></script>



  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>








  <script src="/js/local-search.js?v=7.4.1"></script>





  <script src="//code.tidio.co/ohblyq9gicnjwqem8o1hfoymk3calgui.js"></script>









  

  
    
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    
  

  

  

</body>
</html>
